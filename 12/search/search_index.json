{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Percona Distribution for PostgreSQL 12 Documentation","text":"<p>Percona Distribution for PostgreSQL is a collection of tools to assist you in managing your PostgreSQL database system: it installs PostgreSQL and complements it by a selection of extensions that enable solving essential practical tasks efficiently:</p> <ul> <li> <p>pg_repack rebuilds PostgreSQL database objects</p> </li> <li> <p>pgAudit provides detailed session or object audit logging via the standard PostgreSQL logging facility</p> </li> <li> <p>pgAudit set_user - The <code>set_user</code> part of <code>pgAudit</code> extension provides an additional layer of logging and control when unprivileged users must escalate themselves to superuser or object owner roles in order to perform needed maintenance tasks.</p> </li> <li> <p>pgBackRest is a backup and restore solution for PostgreSQL</p> </li> <li> <p>Patroni is an HA (High Availability) solution for PostgreSQL.</p> </li> <li> <p>pg_stat_monitor collects and aggregates statistics for PostgreSQL and provides histogram information.</p> </li> <li> <p>PgBouncer - a lightweight connection pooler for PostgreSQL</p> </li> <li> <p>pgBadger - a fast PostgreSQL Log Analyzer.</p> </li> <li> <p>wal2json - a PostgreSQL logical decoding JSON output plugin.</p> </li> <li> <p>HAProxy - a high-availability and load-balancing solution</p> </li> <li> <p>A collection of additional PostgreSQL contrib extensions</p> </li> </ul> <p>See also</p> <p>Blog Posts</p> <ul> <li>pgBackRest - A Great Backup Solution and a Wonderful Year of   Growth</li> <li>Securing PostgreSQL as an Enterprise-Grade   Environment</li> </ul> <p>Percona Distribution for PostgreSQL is also shipped with the libpq library. It contains \u201ca set of library functions that allow client programs to pass queries to the PostgreSQL backend server and to receive the results of these queries.\u201d 1</p>"},{"location":"index.html#get-started","title":"Get started","text":"<ul> <li>Install Percona Distribution for PostgreSQL</li> <li>Enable extensions</li> </ul> <ol> <li> <p>https://www.postgresql.org/docs/12/libpq.html\u00a0\u21a9</p> </li> </ol>"},{"location":"apt.html","title":"Install Percona Distribution for PostgreSQL on Debian and Ubuntu","text":"<p>This document describes how to install Percona Server for PostgreSQL from Percona repositories on DEB-based distributions such as Debian and Ubuntu.</p>"},{"location":"apt.html#preconditions","title":"Preconditions","text":"<p>Debian and other systems that use the apt package manager include the upstream PostgreSQL server package (<code>postgresql-12</code>) by default. The components of Percona Distribution for PostgreSQL 12 can only be installed together with the PostgreSQL server shipped by Percona (<code>percona-postgresql-12</code>). If you wish to use Percona Distribution for PostgreSQL, uninstall the <code>postgresql-12</code> and then install the chosen components from Percona Distribution for PostgreSQL.</p>"},{"location":"apt.html#procedure","title":"Procedure","text":"<p>Run all the commands in the following sections as root or using the <code>sudo</code> command:</p>"},{"location":"apt.html#configure-percona-repository","title":"Configure Percona repository","text":"<ol> <li> <p>Install the <code>percona-release</code> repository management tool to subscribe to Percona repositories:</p> <ul> <li> <p>Fetch <code>percona-release</code> packages from Percona web:</p> <pre><code>$ wget https://repo.percona.com/apt/percona-release_latest.$(lsb_release -sc)_all.deb\n</code></pre> </li> <li> <p>Install the downloaded package with <code>dpkg</code>:</p> <pre><code>$ sudo dpkg -i percona-release_latest.$(lsb_release -sc)_all.deb\n</code></pre> </li> <li> <p>Refresh the local cache:</p> <pre><code>$ sudo apt update\n</code></pre> </li> </ul> </li> <li> <p>Enable the repository</p> </li> </ol> <p>Percona provides two repositories for Percona Distribution for PostgreSQL. We recommend enabling the Major release repository to timely receive the latest updates. </p> <p>To enable a repository, we recommend using the <code>setup</code> command: </p> <pre><code>$ sudo percona-release setup ppg-12\n</code></pre>"},{"location":"apt.html#install-packages","title":"Install packages","text":"Install using meta-packageInstall packages individually <pre><code>$ sudo apt install percona-ppg-server-12\n</code></pre> <ol> <li> <p>Install the PostgreSQL server package:</p> <pre><code>$ sudo apt install percona-postgresql-12\n</code></pre> </li> <li> <p>Install the components:</p> <p>Install <code>pg_repack</code>:</p> <pre><code>$ sudo apt install percona-postgresql-12-repack\n</code></pre> <p>Install <code>pgAudit</code>:</p> <pre><code>$ sudo apt install percona-postgresql-12-pgaudit\n</code></pre> <p>Install <code>pgBackRest</code>:</p> <pre><code>$ sudo apt install percona-pgbackrest\n</code></pre> <p>Install <code>Patroni</code>:</p> <pre><code>$ sudo apt install percona-patroni\n</code></pre> <p>Install <code>pg_stat_monitor</code></p> <p>Install <code>pgBouncer</code>:</p> <pre><code>$ sudo apt install percona-pgbouncer\n</code></pre> <p>Install <code>pgAudit-set_user</code>:</p> <pre><code>$ sudo apt install percona-pgaudit12-set-user\n</code></pre> <p>Install <code>pgBadger</code>:</p> <pre><code>$ sudo apt install percona-pgbadger\n</code></pre> <p>Install <code>wal2json</code>:</p> <pre><code>$ sudo apt install percona-postgresql-12-wal2json\n</code></pre> <p>Install PostgreSQL contrib extensions:</p> <pre><code>$ sudo apt install percona-postgresql-contrib\n</code></pre> <p>Install HAProxy</p> <pre><code>$ sudo apt install percona-haproxy\n</code></pre> <p>Some extensions require additional setup in order to use them with Percona Distribution for PostgreSQL. For more information, refer to Enabling extensions.</p> </li> </ol>"},{"location":"apt.html#start-the-service","title":"Start the service","text":"<p>The installation process automatically initializes and starts the default database. You can check the database status using the following command:</p> <pre><code>$ sudo systemctl status postgresql.service\n</code></pre>"},{"location":"apt.html#connect-to-the-postgresql-server","title":"Connect to the PostgreSQL server","text":"<p>By default, <code>postgres</code> user and <code>postgres</code> database are created in PostgreSQL upon its installation and initialization. This allows you to connect to the database as the <code>postgres</code> user.</p> <pre><code>$ sudo su postgres\n</code></pre> <p>Open the PostgreSQL interactive terminal:</p> <pre><code>$ psql\n</code></pre> <p>Hint</p> <p>You can connect to <code>psql</code> as the <code>postgres</code> user in one go:</p> <pre><code>$ sudo su postgres psql\n</code></pre> <p>To exit the <code>psql</code> terminal, use the following command:</p> <pre><code>$ \\q\n</code></pre>"},{"location":"enable-extensions.html","title":"Enable Percona Distribution for PostgreSQL extensions","text":"<p>Some extensions require additional configuration before using them with Percona Distribution for PostgreSQL. This sections provides configuration instructions per extension.</p> <p>Patroni</p> <p>Patroni is the third-party high availability solution for PostgreSQL. The High Availability in PostgreSQL with Patroni chapter provides details about the solution overview and architecture deployment. </p> <p>While setting up a high availability PostgreSQL cluster with Patroni, you will need the following components:</p> <ul> <li> <p>Patroni installed on every <code>postresql</code> node. </p> </li> <li> <p>Distributed Configuration Store (DCS). Patroni supports such DCSs as ETCD, zookeeper, Kubernetes though ETCD is the most popular one. It is available upstream as DEB packages for Debian 10, 11 and Ubuntu 18.04, 20.04, 22.04.  </p> <p>For CentOS 8, RPM packages for ETCD is available within Percona Distribution for PostreSQL.  You can install it using the following command: </p> <pre><code>$ sudo yum install etcd python3-python-etcd\n</code></pre> </li> <li> <p>HAProxy.</p> </li> </ul> <p>See the configuration guidelines for Debian and Ubuntu and RHEL and CentOS. </p> <p>See also</p> <ul> <li> <p>Patroni documentation</p> </li> <li> <p>Percona Blog: </p> <ul> <li>PostgreSQL HA with Patroni: Your Turn to Test Failure Scenarios </li> </ul> </li> </ul> <p>pgBadger</p> <p>Enable the following options in <code>postgresql.conf</code> configuration file before starting the service:</p> <pre><code>log_min_duration_statement = 0\nlog_line_prefix = '%t [%p]: '\nlog_checkpoints = on\nlog_connections = on\nlog_disconnections = on\nlog_lock_waits = on\nlog_temp_files = 0\nlog_autovacuum_min_duration = 0\nlog_error_verbosity = default\n</code></pre> <p>For details about each option, see pdBadger documentation.</p> <p>pgAudit set-user</p> <p>Add the <code>set-user</code> to <code>shared_preload_libraries</code> in <code>postgresql.conf</code>. The recommended way is to use the ALTER SYSTEM command. Connect to psql and use the following command:</p> <pre><code>ALTER SYSTEM SET shared_preload_libraries = 'set-user';\n</code></pre> <p>Start / restart the server to apply the configuration.</p> <p>You can fine-tune user behavior with the custom parameters supplied with the extension.</p> <p>wal2json</p> <p>After the installation, enable the following option in <code>postgresql.conf</code> configuration file before starting the service:</p> <pre><code>wal_level = logical\n</code></pre>"},{"location":"extenstions.html","title":"Extensions","text":"<p>pg_stat_monitor</p>"},{"location":"installing.html","title":"Install Percona Distribution for PostgreSQL","text":"<p>We recommend that you install Percona Distribution for PostgreSQL from Percona repositories using the package manager of your operating system. Find the list of supported Linux distributions on the Percona Software and Platform Lifecycle page page.</p> <p>Installing Percona Distribution for PostgreSQL from Percona repositories means to subscribe to these repositories. Percona provides the percona-release repository management tool for this purpose. It simplifies operating repositories and enables to install and update both Percona Distribution for PostgreSQL packages and required dependencies smoothly.</p>"},{"location":"installing.html#package-contents","title":"Package contents","text":"<p>In addition to individual packages for its components, Percona Distribution for PostgreSQL also includes two meta-packages: <code>percona-ppg-server</code> and <code>percona-ppg-server-ha</code>.</p> <p>Using a meta-package, you can install all components it contains in one go.</p>"},{"location":"installing.html#percona-ppg-server","title":"<code>percona-ppg-server</code>","text":"Package name on Debian/UbuntuPackage name on RHEL/derivatives <p><code>percona-ppg-server-12</code></p> <p><code>percona-ppg-server12</code></p> <p>The <code>percona-ppg-server</code> meta-package installs the PostgreSQL server with the following packages:</p> Package contents Description <code>percona-postgresql%{pgmajorversion}-server</code> The PostgreSQL server package. <code>percona-postgresql-common</code> PostgreSQL database-cluster manager. It provides a structure under which multiple versions of PostgreSQL may be installed and/or multiple clusters maintained at one time. <code>percona-postgresql%{pgmajorversion}-contrib</code> A collection of additional PostgreSQLcontrib extensions <code>percona-pg-stat-monitor%{pgmajorversion}</code> A Query Performance Monitoring tool for PostgreSQL. <code>percona-pgaudit</code> Provides detailed session or object audit logging via the standard PostgreSQL logging facility. <code>percona-pg_repack%{pgmajorversion}</code> rebuilds PostgreSQL database objects. <code>percona-wal2json%{pgmajorversion}</code> a PostgreSQL logical decoding JSON output plugin. <p>The <code>%{pgmajorversion}</code> variable stands for the major version of PostgreSQL.</p>"},{"location":"installing.html#percona-ppg-server-ha","title":"<code>percona-ppg-server-ha</code>","text":"Package name on Debian/UbuntuPackage name on RHEL/derivatives <p><code>percona-ppg-server-ha-12</code></p> <p><code>percona-ppg-server-ha12</code></p> <p>The <code>percona-ppg-server-ha</code> meta-package installs high-availability components that are recommended by Percona:</p> Package contents Description <code>percona-patroni</code> A high-availability solution for PostgreSQL. <code>percona-haproxy</code> A high-availability and load-balancing solution <code>etcd</code> A consistent, distributed key-value store <code>python3-python-etcd</code> A Python client for ETCD.1 <p>To install Percona Distribution for PostgreSQL, refer to the following tutorials:</p> <ul> <li>On Debian and Ubuntu</li> <li>On Red Hat Enterprise Linux and derivatives</li> </ul> <ol> <li> <p>Is included in repositories for RHEL 8 / CentOS 8 operating systems\u00a0\u21a9</p> </li> </ol>"},{"location":"ldap.html","title":"LDAP Authentication","text":"<p>When a client application or a user that runs the client application connects to the database, it must identify themselves. The process of validating the client\u2019s identity and determining whether this client is permitted to access the database it has requested is called authentication. </p> <p>Percona Distribution for PortgreSQL supports several authentication methods, including the LDAP authentication. The use of LDAP is to provide a central place for authentication - meaning the LDAP server stores usernames and passwords and their resource permissions. </p> <p>The LDAP authentication in Percona Distribution for PortgreSQL is implemented the same way as in upstream PostgreSQL.</p>"},{"location":"licensing.html","title":"Licensing","text":"<p>Percona Distribution for PostgreSQL is licensed under the PostgreSQL license and licenses of all components included in the Distribution.</p>"},{"location":"licensing.html#documentation-licensing","title":"Documentation Licensing","text":"<p>Percona Distribution for PostgreSQL documentation is licensed under the PostgreSQL license.</p>"},{"location":"major-upgrade.html","title":"Upgrading Percona Distribution for PostgreSQL from 11 to 12","text":"<p>This document describes the in-place upgrade of Percona Distribution for PostgreSQL using the <code>pg_upgrade</code> tool. The in-place upgrade means installing a new version without removing the old version and keeping the data files on the server.</p> <p>Seealso</p> <p><code>pg_upgrade</code> Documentation:</p> <p>https://www.postgresql.org/docs/12/pgupgrade.html</p> <p>Similar to installing, we recommend you to upgrade Percona Distribution for PostgreSQL from Percona repositories.</p> <p>Important</p> <p>A major upgrade is a risky process because of many changes between versions and issues that might occur during or after the upgrade. Therefore, make sure to back up your data first. The backup tools are out of scope of this document. Use the backup tool of your choice.</p> <p>The general in-place upgrade flow for Percona Distribution for PostgreSQL is the following:</p> <ol> <li> <p>Install Percona Distribution for PostgreSQL 12 packages.</p> </li> <li> <p>Stop the PostgreSQL service.</p> </li> <li> <p>Check the upgrade without modifying the data.</p> </li> <li> <p>Upgrade Percona Distribution for PostgreSQL.</p> </li> <li> <p>Start PostgreSQL service.</p> </li> <li> <p>Execute the  analyze_new_cluster.sh script to generate statistics so the system is usable.</p> </li> <li> <p>Delete old packages and configuration files.</p> </li> </ol> <p>The exact steps may differ depending on the package manager of your operating system.</p>"},{"location":"major-upgrade.html#on-debian-and-ubuntu-using-apt","title":"On Debian and Ubuntu using <code>apt</code>","text":"<p>Important</p> <p>Run all commands as root or via sudo.</p> <ol> <li> <p>Install Percona Distribution for PostgreSQL 12 packages.</p> <ul> <li>Enable Percona repository using the percona-release utility:</li> </ul> <pre><code>$ sudo percona-release setup ppg-12\n</code></pre> <ul> <li>Install Percona Distribution for PostgreSQL 12 package:</li> </ul> <pre><code>$ sudo apt install percona-postgresql-12\n</code></pre> <ul> <li>Install the components:</li> </ul> <pre><code>$ sudo apt install percona-postgresql-12-repack\n$ sudo apt install percona-postgresql-12-pgaudit\n$ sudo apt install percona-pgbackrest\n$ sudo apt install percona-patroni\n$ sudo apt install percona-pg-stat-monitor12\n$ sudo apt install percona-pgbadger\n$ sudo apt install percona-pgaudit12-set-user\n$ sudo apt install percona-pgbadger\n$ sudo apt install percona-postgresql-12-wal2json\n$ sudo apt install percona-postgresql-contrib\n</code></pre> <p>Seealso</p> <p>Percona Documentation:</p> <ul> <li> <p>Percona Software Repositories Documentation</p> </li> <li> <p>Installing Percona Distribution for PostgreSQL</p> </li> </ul> </li> <li> <p>Stop the <code>postgresql</code> service.</p> <pre><code>$ sudo systemctl stop postgresql.service\n</code></pre> <p>This stops both Percona Distribution for PostgreSQL 11 and 12.</p> </li> <li> <p>Run the database upgrade.</p> <ul> <li>Log in as the <code>postgres</code> user.</li> </ul> <pre><code>$ sudo su postgres\n</code></pre> <ul> <li>Change the current directory to the <code>tmp</code> directory where logs and some scripts will be recorded: </li> </ul> <pre><code>cd tmp/\n</code></pre> <ul> <li>Check the ability to upgrade Percona Distribution for PostgreSQL from 11 to 12:</li> </ul> <pre><code>$ /usr/lib/postgresql/12/bin/pg_upgrade\n--old-datadir=/var/lib/postgresql/11/main \\\n--new-datadir=/var/lib/postgresql/12/main  \\\n--old-bindir=/usr/lib/postgresql/11/bin  \\\n--new-bindir=/usr/lib/postgresql/12/bin  \\\n--old-options '-c config_file=/etc/postgresql/11/main/postgresql.conf' \\\n--new-options '-c config_file=/etc/postgresql/12/main/postgresql.conf' \\\n--check\n</code></pre> <p>The <code>--check</code> flag here instructs <code>pg_upgrade</code> to only check the upgrade without changing any data.</p> <ul> <li>Upgrade the Percona Distribution for PostgreSQL</li> </ul> <pre><code>$ /usr/lib/postgresql/12/bin/pg_upgrade\n--old-datadir=/var/lib/postgresql/11/main \\\n--new-datadir=/var/lib/postgresql/12/main  \\\n--old-bindir=/usr/lib/postgresql/11/bin \\\n--new-bindir=/usr/lib/postgresql/12/bin \\\n--old-options '-c config_file=/etc/postgresql/11/main/postgresql.conf' \\\n--new-options '-c config_file=/etc/postgresql/12/main/postgresql.conf' \\\n--link\n</code></pre> <p>The  <code>--link</code> flag creates hard links to the files on the old version cluster so you don\u2019t need to copy data.   If you don\u2019t wish to use the <code>--link</code> option, make sure that you have enough disk space to store 2 copies of files for both old version and new version clusters.</p> <ul> <li>Go back to the regular user: </li> </ul> <pre><code>exit\n</code></pre> <ul> <li>The Percona Distribution for PostgreSQL 11 uses the <code>5432</code> port while the Percona Distribution for PostgreSQL 12 is set up to use the <code>5433</code> port by default. To start the Percona Distribution for PostgreSQL 12, swap ports in the configuration files of both versions.</li> </ul> <pre><code>$ sudo vim /etc/postgresql/12/main/postgresql.conf\n$ port = 5433 # Change to 5432 here\n$ sudo vim /etc/postgresql/11/main/postgresql.conf\n$ port = 5432 # Change to 5433 here\n</code></pre> </li> <li> <p>Start the <code>postgreqsl</code> service.</p> <pre><code>$ sudo systemctl start postgresql.service\n</code></pre> </li> <li> <p>Check the <code>postgresql</code> version.</p> <pre><code>$ #Log in as a postgres user\n$ sudo su postgres\n$ #Check the database version\n$ psql -c \"SELECT version();\"\n</code></pre> </li> <li> <p>Run the analyze_new_cluster.sh script</p> <pre><code>$ tmp/analyze_new_cluster.sh\n$ #Logout\n$ exit\n</code></pre> </li> <li> <p>Delete Percona Distribution for PostgreSQL 11 packages and configuration files</p> <ul> <li>Remove packages</li> </ul> <pre><code>$ sudo apt remove percona-postgresql-11* percona-pgbackrest percona-patroni percona-pg-stat-monitor11 percona-pgaudit11-set-user percona-pgbadger percona-pgbouncer percona-postgresql-11-wal2json\n</code></pre> <ul> <li>Remove old files</li> </ul> <pre><code>$ sudo rm -rf /etc/postgresql/11/main\n</code></pre> </li> </ol>"},{"location":"major-upgrade.html#on-red-hat-enterprise-linux-and-centos-using-yum","title":"On Red Hat Enterprise Linux and CentOS using <code>yum</code>","text":"<p>Important</p> <p>Run all commands as root or via sudo.</p> <ol> <li> <p>Install Percona Distribution for PostgreSQL 12 packages</p> <ul> <li>Enable Percona repository using the percona-release utility:</li> </ul> <pre><code>$ sudo percona-release setup ppg-12\n</code></pre> <ul> <li>Install Percona Distribution for PostgreSQL 12:</li> </ul> <pre><code>$ sudo yum install percona-postgresql12-server\n</code></pre> <ul> <li>Install components:</li> </ul> <pre><code>$ sudo yum install percona-pgaudit\n$ sudo yum install percona-pgbackrest\n$ sudo yum install percona-pg_repack12\n$ sudo yum install percona-patroni\n$ sudo yum install percona-pg-stat-monitor12\n$ sudo yum install percona-pgbadger\n$ sudo yum install percona-pgaudit12_set_user\n$ sudo yum install percona-pgbadger\n$ sudo yum install percona-wal2json12\n$ sudo yum install percona-postgresql12-contrib\n</code></pre> </li> <li> <p>Set up Percona Distribution for PostgreSQL 12 cluster</p> <ul> <li>Log is as the postgres user</li> </ul> <pre><code>$ sudo su postgres\n$ #Set up locale settings\n$ export LC_ALL=\"en_US.UTF-8\"\n$ export LC_CTYPE=\"en_US.UTF-8\"\n$ #Initialize cluster with the new data directory\n$ /usr/pgsql-12/bin/initdb -D /var/lib/pgsql/12/data\n</code></pre> </li> <li> <p>Stop the <code>postgresql</code> 11 service</p> <pre><code>$ sudo systemctl stop postgresql-11\n</code></pre> </li> <li> <p>Run the database upgrade.</p> <ul> <li>Log in as the <code>postgres</code> user</li> </ul> <pre><code>$ sudo su postgres\n</code></pre> <ul> <li>Check the ability to upgrade Percona Distribution for PostgreSQL from 11 to 12:</li> </ul> <pre><code>$ /usr/pgsql-12/bin/pg_upgrade \\\n--old-bindir /usr/pgsql-11/bin \\\n--new-bindir /usr/pgsql-12/bin \\\n--old-datadir /var/lib/pgsql/11/data \\\n--new-datadir /var/lib/pgsql/12/data \\\n--link \\\n--check\n</code></pre> <p>The <code>--check</code> flag here instructs <code>pg_upgrade</code> to only check the upgrade without changing any data.</p> <ul> <li>Upgrade the Percona Distribution for PostgreSQL</li> </ul> <pre><code>$ /usr/pgsql-12/bin/pg_upgrade \\\n--old-bindir /usr/pgsql-11/bin \\\n--new-bindir /usr/pgsql-12/bin \\\n--old-datadir /var/lib/pgsql/11/data \\\n--new-datadir /var/lib/pgsql/12/data \\\n--link\n</code></pre> <p>The  <code>--link</code> flag creates hard links to the files on the old version cluster so you don\u2019t need to copy data.    If you don\u2019t wish to use the <code>--link</code> option, make sure that you have enough disk space to store 2 copies of files for both old version and new version clusters.</p> </li> <li> <p>Start the <code>postgresql</code> 12 service.</p> <pre><code>$ #Start postgresql service\n$ sudo systemctl start postgresql-12\n$ #Check postgresql status\n$ sudo systemctl status postgresql-12\n</code></pre> </li> <li> <p>Run the analyze_new_cluster.sh script</p> <pre><code>$ #Log in as the postgres user\n$ sudo su postgres\n$ #Run the script\n$ ./analyze_new_cluster.sh\n</code></pre> </li> <li> <p>Delete Percona Distribution for PostgreSQL 11 configuration files</p> <pre><code>$ ./delete_old_cluster.sh\n</code></pre> </li> <li> <p>Delete Percona Distribution for PostgreSQL 11 packages</p> <ul> <li>Remove packages</li> </ul> <pre><code>$ sudo yum -y remove percona-postgresql-11*\n</code></pre> <ul> <li>Remove old files</li> </ul> <pre><code>$ sudo rm -rf /var/lib/pgsql/11/data\n</code></pre> </li> </ol>"},{"location":"migration.html","title":"Migrate from PostgreSQL to Percona Distribution for PostgreSQL","text":"<p>Percona Distribution for PostgreSQL includes the PostgreSQL database and additional extensions that have been selected to cover the needs of the enterprise and are guaranteed to work together. Percona Distribution for PostgreSQL is available as a software collection that is easy to deploy.</p> <p>We encourage users to migrate from their PostgreSQL deployments based on community binaries to Percona Distribution for PostgreSQL. This document provides the migration instructions. </p> <p>Depending on your business requirements, you may migrate to Percona Distribution for PostgreSQL either on the same server or onto a different server. </p>"},{"location":"migration.html#migrate-on-the-same-server","title":"Migrate on the same server","text":"On Debian and Ubuntu LinuxOn RHEL and compatible derivatives <p>To ensure that your data is safe during the migration, we recommend to make a backup of your data and all configuration files (such as <code>pg_hba.conf</code>, <code>postgresql.conf</code>, <code>postgresql.auto.conf</code>) using the tool of your choice. The backup process is out of scope of this document. You can use <code>pg_dumpall</code> or other tools of your choice. </p> <ol> <li> <p>Stop the <code>postgresql</code> server   </p> <pre><code>$ sudo systemctl stop postgresql.service\n</code></pre> </li> <li> <p>Remove community packages</p> <pre><code>$ sudo apt-get --purge remove postgresql\n</code></pre> </li> <li> <p>Install percona-release</p> </li> <li> <p>Enable the repository</p> <pre><code>$ sudo percona-release setup ppg12\n</code></pre> </li> <li> <p>Install Percona Distribution for PostgreSQL packages</p> </li> <li>(Optional) Restore the data from the backup.</li> <li> <p>Start the <code>postgresql</code> service. The installation process starts and initializes the default cluster automatically. You can check its status with: </p> <pre><code>$ sudo systemctl status postgresql\n</code></pre> <p>If <code>postresql</code> service is not started, start it manually:</p> <pre><code>$ sudo systemctl start postgresql.service\n</code></pre> </li> </ol> <p>To ensure that your data is safe during the migration, we recommend to make a backup of your data and all configuration files (such as <code>pg_hba.conf</code>, <code>postgresql.conf</code>, <code>postgresql.auto.conf</code>) using the tool of your choice. The backup process is out of scope of this document. You can use <code>pg_dumpall</code> or other tools of your choice. </p> <ol> <li> <p>Stop the <code>postgresql</code> server   </p> <pre><code>$ sudo systemctl stop postgresql-12\n</code></pre> </li> <li> <p>Remove community packages</p> <pre><code>$ sudo yum remove postgresql\n</code></pre> </li> <li> <p>Install percona-release</p> </li> <li> <p>Enable the repository</p> <pre><code>$ sudo percona-release setup ppg12\n</code></pre> </li> <li> <p>Install Percona Distribution for PostgreSQL packages</p> </li> <li>(Optional) Restore the data from the backup.</li> <li> <p>Start the <code>postgresql</code> service</p> <pre><code>$ sudo systemctl start postgresql-12\n</code></pre> </li> </ol>"},{"location":"migration.html#migrate-on-a-different-server","title":"Migrate on a different server","text":"<p>In this scenario, we will refer to the server with PostgreSQL Community as the \u201csource\u201d and to the server with Percona Distribution for PostgreSQL as the \u201ctarget\u201d.</p> <p>To migrate from PostgreSQL Community to Percona Distribution for PostgreSQL on a different server, do the following:</p> <p>On the source server:</p> <ol> <li>Back up your data and all configuration files (such as <code>pg_hba.conf</code>, <code>postgresql.conf</code>, <code>postgresql.auto.conf</code>) using the tool of your choice.</li> <li> <p>Stop the <code>postgresql</code> service</p> On Debian and UbuntuOn RHEL and derivatives <pre><code>$ sudo systemctl stop postgresql.service\n</code></pre> <pre><code>$ sudo systemctl stop postgresql-12\n</code></pre> </li> <li> <p>Optionally, remove PostgreSQL Community packages </p> </li> </ol> <p>On the target server:</p> <ol> <li>Install percona-release </li> <li> <p>Enable the repository</p> <pre><code>$ sudo percona-release setup ppg12\n</code></pre> </li> <li> <p>Install Percona Distribution for PostgreSQL packages on the target server.</p> </li> <li>Restore the data from the backup</li> <li> <p>Start <code>postgresql</code> service</p> On Debian and UbuntuOn RHEL and compatible derivatives <pre><code>$ sudo systemctl start postgresql.service\n</code></pre> <pre><code>$ sudo systemctl start postgresql-12\n</code></pre> </li> </ol>"},{"location":"minor-upgrade.html","title":"Minor Upgrade of Percona Distribution for PostgreSQL","text":"<p>Minor releases of PostgreSQL include bug fixes and feature enhancements. We recommend that you keep your Percona Distribution for PostgreSQL updated to the latest minor version.</p> <p>Though minor upgrades do not change the behavior, we recommend you to back up your data first, in order to be on the safe side.</p> <p>Minor upgrade of Percona Distribution for PostgreSQL includes the following steps:</p> <ol> <li> <p>Stopping the <code>postgresql</code> cluster;</p> </li> <li> <p>Installing new version packages;</p> </li> <li> <p>Restarting the <code>postgresql</code> cluster.</p> </li> </ol> <p>Note</p> <p>These steps apply if you installed Percona Distribution for PostgreSQL from the Major Release repository. In this case, you are always upgraded to the latest available release.</p> <p>If you installed Percona Distribution for PostgreSQL from the Minor Release repository, you will need to enable a new version repository to upgrade.</p> <p>For more information about Percona repositories, refer to Installing Percona Distribution for PostgreSQL.</p> <p>Before the upgrade, update the percona-release utility to the latest version. This is required to install the new version packages of Percona Distribution for PostgreSQL. Refer to Percona Software Repositories Documentation for update instructions.</p> <p>Important</p> <p>Run all commands as root or via sudo.</p> <ol> <li> <p>Stop the <code>postgresql</code> service.</p> On Debian / UbuntuOn Red Hat Enterprise Linux / derivatives <pre><code>$ sudo systemctl stop postgresql.service\n</code></pre> <pre><code>$ sudo systemctl stop postgresql-12\n</code></pre> </li> <li> <p>Install new version packages. See Installing Percona Distribution for PostgreSQL.</p> </li> <li> <p>Restart the <code>postgresql</code> service.</p> On Debian / UbuntuOn Red Hat Enterprise Linux / derivatives <pre><code>$ sudo systemctl start postgresql.service\n</code></pre> <pre><code>$ sudo systemctl start postgresql-12\n</code></pre> </li> </ol> <p>If you wish to upgrade Percona Distribution for PostgreSQL to the major version, refer to Upgrading Percona Distribution for PostgreSQL from 11 to 12.</p>"},{"location":"pg-stat-monitor.html","title":"pg_stat_monitor","text":"<p>Note</p> <p>This document describes the functionality of pg_stat_monitor 1.0.0.</p>"},{"location":"pg-stat-monitor.html#overview","title":"Overview","text":"<p><code>pg_stat_monitor</code> is a  Query Performance Monitoring tool for PostgreSQL. It collects various statistics data such as query statistics, query plan, SQL comments and other performance insights. The collected data is aggregated and presented in a single view. This allows you to view queries from performance, application and analysis perspectives.</p> <p><code>pg_stat_monitor</code> groups statistics data and writes it in a storage unit called bucket. The data is added and stored in a bucket for the defined period \u2013 the bucket lifetime. This allows you to identify performance issues and patterns based on time.</p> <p>You can specify the following:</p> <ul> <li>The number of buckets. Together they form a bucket chain.</li> <li>Bucket size. This is the amount of shared memory allocated for buckets. Memory is divided equally among buckets.</li> <li>Bucket lifetime.</li> </ul> <p>When a bucket lifetime expires, <code>pg_stat_monitor</code> resets all statistics and writes the data in the next bucket in the chain. When the last bucket\u2019s lifetime expires, <code>pg_stat_monitor</code> returns to the first bucket.</p> <p>Important</p> <p>The contents of the bucket will be overwritten. In order not to lose the data, make sure to read the bucket before <code>pg_stat_monitor</code> starts writing new data to it.</p>"},{"location":"pg-stat-monitor.html#views","title":"Views","text":"<p><code>pg_stat_monitor</code> provides two views:</p> <ul> <li><code>pg_stat_monitor</code> is the view where statistics data is presented.</li> <li><code>pg_stat_monitor_settings</code> view shows available configuration options which you can change. </li> </ul>"},{"location":"pg-stat-monitor.html#pg_stat_monitor-view","title":"pg_stat_monitor view","text":"<p>The <code>pg_stat_monitor</code> view contains all the statistics collected and aggregated by the extension. This view contains one row for each distinct combination of metrics and whether it is a top-level statement or not (up to the maximum number of distinct statements that the module can track). For details about available metrics, refer to the <code>pg_stat_monitor</code> view reference.</p> <p>The following are the primary keys for pg_stat_monitor:</p> <ul> <li><code>bucket</code>,</li> <li><code>userid</code>,</li> <li><code>dbid</code>,</li> <li><code>client_ip</code>,</li> <li><code>application_name</code>.</li> </ul> <p>A new row is created for each key in the <code>pg_stat_monitor</code> view.</p> <p>For security reasons, only superusers and members of the <code>pg_read_all_stats</code> role are allowed to see the SQL text and <code>queryid</code> of queries executed by other users. Other users can see the statistics, however, if the view has been installed in their database.</p>"},{"location":"pg-stat-monitor.html#pg_stat_monitor_settings-view","title":"pg_stat_monitor_settings view","text":"<p>The <code>pg_stat_monitor_settings</code> view shows one row per <code>pg_stat_monitor</code> configuration parameter. It displays configuration parameter name, value, default value, description, minimum and maximum values, and whether a restart is required for a change in value to be effective.</p> <p>To learn more, see the Changing the configuration section.</p>"},{"location":"pg-stat-monitor.html#installation","title":"Installation","text":"<p>This section describes how to install <code>pg_stat_monitor</code> from Percona repositories. To learn about other installation methods, see the Installation section in the <code>pg_stat_monitor</code> documentation.</p> <p>Preconditions:</p> <p>To install <code>pg_stat_monitor</code> from Percona repositories, you need to subscribe to them. To do this, you must have the <code>percona-release</code> repository management tool up and running. </p> <p>To install <code>pg_stat_monitor</code>, run the following commands:</p> On Debian and UbuntuOn Red Hat Enterprise Linux and derivatives <ol> <li> <p>Enable the repository</p> <pre><code>$ sudo percona-release setup ppg12\n</code></pre> </li> <li> <p>Update the local cache</p> <pre><code>$ sudo apt update\n</code></pre> </li> <li> <p>Install the package:</p> <pre><code>$ sudo apt-get install percona-pg-stat-monitor12\n</code></pre> </li> </ol> <ol> <li> <p>Enable the repository</p> <pre><code>$ sudo percona-release setup ppg12\n</code></pre> </li> <li> <p>Install the package:</p> <pre><code>$ sudo yum install percona-pg-stat-monitor12\n</code></pre> </li> </ol>"},{"location":"pg-stat-monitor.html#setup","title":"Setup","text":"<p><code>pg_stat_monitor</code> requires additional setup in order to use it with PostgreSQL. The setup steps are the following:</p> <ol> <li> <p>Add <code>pg_stat_monitor</code> in the <code>shared_preload_libraries</code> configuration parameter.</p> <p>The recommended way to modify PostgreSQL configuration file is using the ALTER SYSTEM command. Connect to <code>psql</code> and use the following command:</p> <pre><code>ALTER SYSTEM SET shared_preload_libraries = 'pg_stat_monitor';\n</code></pre> <p>The parameter value is written to the <code>postgresql.auto.conf</code> file which is read in addition with <code>postgresql.conf</code> file.</p> <p>Note</p> <p>To use <code>pg_stat_monitor</code> together with <code>pg_stat_statements</code>, specify both modules separated by commas for the <code>ALTER SYSTEM SET</code> command. </p> <p>The order of modules is important: <code>pg_stat_monitor</code> must be specified after <code>pg_stat_statements</code>: </p> <pre><code>ALTER SYSTEM SET shared_preload_libraries = \u2018pg_stat_statements, pg_stat_monitor\u2019\n</code></pre> </li> <li> <p>Start or restart the <code>postgresql</code> instance to enable <code>pg_stat_monitor</code>. Use the following command for restart:</p> On Debian and UbuntuOn Red Hat Enterprise Linux and derivatives <pre><code>$ sudo systemctl restart postgresql.service\n</code></pre> <pre><code>$ sudo systemctl restart postgresql-12\n</code></pre> </li> <li> <p>Create the extension. Connect to <code>psql</code> and use the following command:</p> <pre><code>CREATE EXTENSION pg_stat_monitor;\n</code></pre> <p>By default, the extension is created against the <code>postgres</code> database. You need to create the extension on every database where you want to collect statistics.</p> </li> </ol> <p>Tip</p> <p>To check the version of the extension, run the following command in the <code>psql</code> session:</p> <pre><code>SELECT pg_stat_monitor_version();\n</code></pre>"},{"location":"pg-stat-monitor.html#usage","title":"Usage","text":"<p>For example, to view the IP address of the client application that made the query, run the following command:</p> <pre><code>SELECT DISTINCT userid::regrole, pg_stat_monitor.datname, substr(query,0, 50)\nAS query, calls, client_ip\nFROM pg_stat_monitor, pg_database\nWHERE pg_database.oid = oid;\n\nuserid  | datname  |                       query                       | calls | client_ip\n----------+----------+---------------------------------------------------+-------+-----------\npostgres | postgres | select bucket, bucket_start_time, query,calls fro |     1 | 127.0.0.1\npostgres | postgres | SELECT c.relchecks, c.relkind, c.relhasindex, c.r |     1 | 127.0.0.1\npostgres | postgres | SELECT  userid,  total_time, min_time, max_time,  |     1 | 127.0.0.1\n</code></pre> <p>Find more usage examples in the <code>pg_stat_monitor</code> user guide.</p>"},{"location":"pg-stat-monitor.html#changing-the-configuration","title":"Changing the configuration","text":"<p>Run the following query to list available configuration parameters.</p> <pre><code>SELECT name,description FROM pg_stat_monitor_settings;\n</code></pre> <p>Output</p> <pre><code>name                      |                            description\n-----------------------------------------------+-------------------------------------------------------------------\n pg_stat_monitor.pgsm_max                      | Sets the maximum number of statements tracked by pg_stat_monitor.\n pg_stat_monitor.pgsm_query_max_len            | Sets the maximum length of query.\n pg_stat_monitor.pgsm_enable                   | Enable/Disable statistics collector.\n pg_stat_monitor.pgsm_track_utility            | Selects whether utility commands are tracked.\n pg_stat_monitor.pgsm_normalized_query         | Selects whether save query in normalized format.\n pg_stat_monitor.pgsm_max_buckets              | Sets the maximum number of buckets.\n pg_stat_monitor.pgsm_bucket_time              | Sets the time in seconds per bucket.\n pg_stat_monitor.pgsm_histogram_min            | Sets the time in millisecond.\n pg_stat_monitor.pgsm_histogram_max            | Sets the time in millisecond.\n pg_stat_monitor.pgsm_histogram_buckets        | Sets the maximum number of histogram buckets\n pg_stat_monitor.pgsm_query_shared_buffer      | Sets the maximum size of shared memory in (MB) used for query tracked by pg_stat_monitor.\n pg_stat_monitor.pgsm_overflow_target          | Sets the overflow target for pg_stat_monitor\n pg_stat_monitor.pgsm_enable_query_plan        | Enable/Disable query plan monitoring\n pg_stat_monitor.pgsm_track_planning           | Selects whether planning statistics are tracked.\n</code></pre> <p>You can change a parameter by setting a new value in the configuration file. Some parameters require server restart to apply a new value. For others, configuration reload is enough. Refer to the configuration parameters of the <code>pg_stat_monitor</code> documentation for the parameters\u2019 description, how you can change their values and if the server restart is required to apply them.</p> <p>As an example, let\u2019s set the bucket lifetime from default 60 seconds to 100 seconds. Use the ALTER SYSTEM command:</p> <pre><code>ALTER SYSTEM set pg_stat_monitor.pgsm_bucket_time = 100;\n</code></pre> <p>Restart the server to apply the change:</p> On Debian and UbuntuOn Red Hat Enterprise Linux and derivatives <pre><code>$ sudo systemctl restart restart postgresql.service\n</code></pre> <pre><code>$ sudo systemctl restart postgresql-12\n</code></pre> <p>Verify the updated parameter:</p> <pre><code>SELECT name, value\nFROM pg_stat_monitor_settings\nWHERE name = 'pg_stat_monitor.pgsm_bucket_time';\n\nname               | value\n----------------------------------+-------\npg_stat_monitor.pgsm_bucket_time |   100\n</code></pre> <p>See also</p> <p><code>pg_stat_monitor</code> Documentation</p> <p>Percona Blog:</p> <ul> <li>pg_stat_monitor: A New Way Of Looking At PostgreSQL Metrics</li> <li>Improve PostgreSQL Query Performance Insights with pg_stat_monitor</li> </ul>"},{"location":"release-notes-v12.10.html","title":"Percona Distribution for PostgreSQL 12.10 (2022-03-30)","text":"Date: March 30, 2022 Installation: Installing Percona Distribution for PostgreSQL <p>Percona Distribution for PostgreSQL is a collection of tools to assist you in managing PostgreSQL. Percona Distribution for PostgreSQL installs PostgreSQL and complements it by a selection of extensions that enable solving essential practical tasks efficiently.</p> <p>This release of Percona Distribution for PostgreSQL is based on PostgreSQL 12.10.</p> <p>The following is the list of extensions available in Percona Distribution for PostgreSQL.</p> Extension Version Description Patroni 2.1.2 a HA (High Availability) solution for PostgreSQL pgAudit 1.4.2 provides detailed session or object audit logging via the standard logging facility provided by PostgreSQL pgAudit set_user 3.0.0 provides an additional layer of logging and control when unprivileged users must escalate themselves to superuser or object owner roles in order to perform needed maintenance tasks. pgBackRest 2.37 a backup and restore solution for PostgreSQL pgBadger 11.7 a fast PostgreSQL Log Analyzer PgBouncer 1.16.1 a lightweight connection pooler for PostgreSQL pg_repack 1.4.7 rebuilds PostgreSQL database objects pg_stat_monitor 1.0.0 - rc.1 collects and aggregates statistics for PostgreSQL and provides histogram information. PostgreSQL Common 237 PostgreSQL database-cluster manager. It provides a structure under which multiple versions of PostgreSQL may be installed and/or multiple clusters maintained at one time. wal2json 2.4 a PostgreSQL logical decoding JSON output plugin. <p>Percona Distribution for PostgreSQL also includes the following packages:</p> <ul> <li><code>llvm</code> 12.0.1 packages for Red Hat Enterprise Linux 8 and derivatives. This fixes compatibility issues with LLVM from upstream.</li> <li>supplemental <code>ETCD</code> packages which can be used for setting up Patroni clusters. These packages are available for the following operating systems:</li> </ul> Operating System Package Version Description RHEL 7 <code>python3-python-etcd</code> 0.4.3 A Python client for ETCD RHEL 8 <code>etcd</code> 3.3.11 A consistent, distributed key-value store <code>python3-python-etcd</code> 0.4.3 A Python client for ETCD Debian 9 (\u2018stretch\u2019) <code>etcd</code> 3.3.11 A consistent, distributed key-value store <code>python3-etcd</code> 0.4.3 A Python client for ETCD <p>Percona Distribution for PostgreSQL is also shipped with the libpq library. It contains \u201ca set of library functions that allow client programs to pass queries to the PostgreSQL backend server and to receive the results of these queries.\u201d </p>"},{"location":"release-notes-v12.10.upd.html","title":"Percona Distribution for PostgreSQL 12.10 Update (2022-04-14)","text":"Date: April 14, 2022 Installation: Installing Percona Distribution for PostgreSQL <p>Percona Distribution for PostgreSQL is a collection of tools to assist you in managing PostgreSQL. Percona Distribution for PostgreSQL installs PostgreSQL and complements it by a selection of extensions that enable solving essential practical tasks efficiently.</p> <p>This update of Percona Distribution for PostgreSQL includes pg_stat_monitor 1.0.0-rc.2 - the new version of the statistics collection tool for PostgreSQL.</p> <p>We welcome your feedback on your experience with <code>pg_stat_monitor</code> on our Forum and in the public JIRA project.</p>"},{"location":"release-notes-v12.10.upd2.html","title":"Percona Distribution for PostgreSQL 12.10 Second Update (2022-05-05)","text":"Date: May 5, 2022 Installation: Installing Percona Distribution for PostgreSQL <p>Percona Distribution for PostgreSQL is a collection of tools to assist you in managing PostgreSQL. Percona Distribution for PostgreSQL installs PostgreSQL and complements it by a selection of extensions that enable solving essential practical tasks efficiently.</p> <p>This update of Percona Distribution for PostgreSQL includes the general availability release of pg_stat_monitor 1.0.0 - the statistics collection tool for PostgreSQL.</p> <p>We welcome your feedback on your experience with <code>pg_stat_monitor</code> on our Forum and in the public JIRA project.</p>"},{"location":"release-notes-v12.11.html","title":"Percona Distribution for PostgreSQL 12.11 (2022-06-06)","text":"Date: June 6, 2022 Installation: Installing Percona Distribution for PostgreSQL <p>Percona Distribution for PostgreSQL is a collection of tools to assist you in managing PostgreSQL. Percona Distribution for PostgreSQL installs PostgreSQL and complements it by a selection of extensions that enable solving essential practical tasks efficiently.</p> <p>This release of Percona Distribution for PostgreSQL is based on PostgreSQL 12.11. </p>"},{"location":"release-notes-v12.11.html#release-highlights","title":"Release Highlights","text":"<p>The set of extensions supplied with Percona Distribution for PostgreSQL now includes the HAProxy - a high-availability and load-balancing solution.</p> <p>The following is the list of extensions available in Percona Distribution for PostgreSQL.</p> Extension Version Description Patroni 2.1.3 a HA (High Availability) solution for PostgreSQL pgAudit 1.4.3 provides detailed session or object audit logging via the standard logging facility provided by PostgreSQL pgAudit set_user 3.0.0 provides an additional layer of logging and control when unprivileged users must escalate themselves to superuser or object owner roles in order to perform needed maintenance tasks. pgBackRest 2.38 a backup and restore solution for PostgreSQL pgBadger 11.8 a fast PostgreSQL Log Analyzer PgBouncer 1.17.0 a lightweight connection pooler for PostgreSQL pg_repack 1.4.7 rebuilds PostgreSQL database objects pg_stat_monitor 1.0.0 collects and aggregates statistics for PostgreSQL and provides histogram information. PostgreSQL Common 241 PostgreSQL database-cluster manager. It provides a structure under which multiple versions of PostgreSQL may be installed and/or multiple clusters maintained at one time. wal2json 2.4 a PostgreSQL logical decoding JSON output plugin. HAProxy 2.5.6 a high-availability and load-balancing solution <p>Percona Distribution for PostgreSQL also includes the following packages:</p> <ul> <li><code>llvm</code> 12.0.1 packages for Red Hat Enterprise Linux 8 and derivatives. This fixes compatibility issues with LLVM from upstream.</li> <li>supplemental <code>ETCD</code> packages which can be used for setting up Patroni clusters. These packages are available for the following operating systems:</li> </ul> Operating System Package Version Description RHEL 7 <code>python3-python-etcd</code> 0.4.3 A Python client for ETCD RHEL 8 <code>etcd</code> 3.3.11 A consistent, distributed key-value store <code>python3-python-etcd</code> 0.4.3 A Python client for ETCD Debian 9 (\u2018stretch\u2019) <code>etcd</code> 3.3.11 A consistent, distributed key-value store <code>python3-etcd</code> 0.4.3 A Python client for ETCD <p>Percona Distribution for PostgreSQL is also shipped with the libpq library. It contains \u201ca set of library functions that allow client programs to pass queries to the PostgreSQL backend server and to receive the results of these queries.\u201d </p>"},{"location":"release-notes-v12.12.html","title":"Percona Distribution for PostgreSQL 12.12 (2022-09-07)","text":"Release date: September 7, 2022 Installation: Installing Percona Distribution for PostgreSQL <p>Percona Distribution for PostgreSQL is a collection of tools to assist you in managing PostgreSQL. Percona Distribution for PostgreSQL installs PostgreSQL and complements it by a selection of extensions that enable solving essential practical tasks efficiently.</p> <p>This release of Percona Distribution for PostgreSQL is based on PostgreSQL 12.12. </p> <p>The following is the list of extensions available in Percona Distribution for PostgreSQL.</p> Extension Version Description Patroni 2.1.4 a HA (High Availability) solution for PostgreSQL pgAudit 1.4.3 provides detailed session or object audit logging via the standard logging facility provided by PostgreSQL pgAudit set_user 3.0.0 provides an additional layer of logging and control when unprivileged users must escalate themselves to superuser or object owner roles in order to perform needed maintenance tasks. pgBackRest 2.40 a backup and restore solution for PostgreSQL pgBadger 11.8 a fast PostgreSQL Log Analyzer PgBouncer 1.17.0 a lightweight connection pooler for PostgreSQL pg_repack 1.4.7 rebuilds PostgreSQL database objects pg_stat_monitor 1.1.0 collects and aggregates statistics for PostgreSQL and provides histogram information. PostgreSQL Common 241 PostgreSQL database-cluster manager. It provides a structure under which multiple versions of PostgreSQL may be installed and/or multiple clusters maintained at one time. wal2json 2.4 a PostgreSQL logical decoding JSON output plugin. HAProxy 2.5.6 a high-availability and load-balancing solution <p>Percona Distribution for PostgreSQL also includes the following packages:</p> <ul> <li><code>llvm</code> 12.0.1 packages for Red Hat Enterprise Linux 8 and derivatives. This fixes compatibility issues with LLVM from upstream.</li> <li>supplemental <code>ETCD</code> packages which can be used for setting up Patroni clusters. These packages are available for the following operating systems:</li> </ul> Operating System Package Version Description RHEL 7 <code>python3-python-etcd</code> 0.4.3 A Python client for ETCD RHEL 8 <code>etcd</code> 3.3.11 A consistent, distributed key-value store <code>python3-python-etcd</code> 0.4.3 A Python client for ETCD <p>Percona Distribution for PostgreSQL is also shipped with the libpq library. It contains \u201ca set of library functions that allow client programs to pass queries to the PostgreSQL backend server and to receive the results of these queries.\u201d </p>"},{"location":"release-notes-v12.13.html","title":"Percona Distribution for PostgreSQL 12.13 (2022-12-01)","text":"Release date: December 1, 2022 Installation: Installing Percona Distribution for PostgreSQL <p>Percona Distribution for PostgreSQL is a collection of tools to assist you in managing PostgreSQL. Percona Distribution for PostgreSQL installs PostgreSQL and complements it by a selection of extensions that enable solving essential practical tasks efficiently.</p> <p>This release of Percona Distribution for PostgreSQL is based on PostgreSQL 12.13. </p> <p>The following is the list of extensions available in Percona Distribution for PostgreSQL.</p> Extension Version Description Patroni 2.1.4 a HA (High Availability) solution for PostgreSQL pgAudit 1.4.3 provides detailed session or object audit logging via the standard logging facility provided by PostgreSQL pgAudit set_user 4.0.0 provides an additional layer of logging and control when unprivileged users must escalate themselves to superuser or object owner roles in order to perform needed maintenance tasks. pgBackRest 2.41 a backup and restore solution for PostgreSQL pgBadger 12.0 a fast PostgreSQL Log Analyzer PgBouncer 1.17.0 a lightweight connection pooler for PostgreSQL pg_repack 1.4.8 rebuilds PostgreSQL database objects pg_stat_monitor 1.1.1 collects and aggregates statistics for PostgreSQL and provides histogram information. PostgreSQL Common 241 PostgreSQL database-cluster manager. It provides a structure under which multiple versions of PostgreSQL may be installed and/or multiple clusters maintained at one time. wal2json 2.5 a PostgreSQL logical decoding JSON output plugin. HAProxy 2.5.9 a high-availability and load-balancing solution <p>Percona Distribution for PostgreSQL also includes the following packages:</p> <ul> <li><code>llvm</code> 12.0.1 packages for Red Hat Enterprise Linux 8 and derivatives. This fixes compatibility issues with LLVM from upstream.</li> <li>supplemental <code>ETCD</code> packages which can be used for setting up Patroni clusters. These packages are available for the following operating systems:</li> </ul> Operating System Package Version Description RHEL 7 <code>python3-python-etcd</code> 0.4.3 A Python client for ETCD RHEL 8 <code>etcd</code> 3.3.11 A consistent, distributed key-value store <code>python3-python-etcd</code> 0.4.3 A Python client for ETCD <p>Percona Distribution for PostgreSQL is also shipped with the libpq library. It contains \u201ca set of library functions that allow client programs to pass queries to the PostgreSQL backend server and to receive the results of these queries.\u201d </p>"},{"location":"release-notes-v12.2.html","title":"Percona Distribution for PostgreSQL 12.2 (2020-05-15)","text":"Date: May 15, 2020 Installation: Installing Percona Distribution for PostgreSQL <p>Percona Distribution for PostgreSQL is a collection of tools to assist you in managing PostgreSQL. Percona Distribution for PostgreSQL installs PostgreSQL and complements it by a selection of extensions that enable solving essential practical tasks efficiently.</p> <ul> <li> <p>Pg_repack rebuilds PostgreSQL database objects.</p> </li> <li> <p>Pgaudit provides detailed session or object audit logging via the standard logging facility provided by PostgreSQL</p> </li> <li> <p>pgBackRest - a backup and restore solution for PostgreSQL</p> </li> <li> <p>Patroni - an HA (High Availability) solution for PostgreSQL</p> </li> <li> <p>A collection of additional PostgreSQL contrib extensions</p> </li> </ul> <p>Percona Distribution for PostgreSQL is also shipped with the libpq library. It contains \u201ca set of library functions that allow client programs to pass queries to the PostgreSQL backend server and to receive the results of these queries.\u201d </p> <p>This release of Percona Distribution for PostgreSQL is based on PostgreSQL 12.2.</p> <p>High Availability</p>"},{"location":"release-notes-v12.3.html","title":"Percona Distribution for PostgreSQL 12.3 (2020-06-11)","text":"Date: June 11, 2020 Installation: Installing Percona Distribution for PostgreSQL <p>Percona Distribution for PostgreSQL is a collection of tools to assist you in managing PostgreSQL. Percona Distribution for PostgreSQL installs PostgreSQL and complements it by a selection of extensions that enable solving essential practical tasks efficiently:</p> <ul> <li> <p>Pg_repack rebuilds PostgreSQL database objects.</p> </li> <li> <p>Pgaudit provides detailed session or object audit logging via the standard logging facility provided by PostgreSQL</p> </li> <li> <p>pgBackRest - a backup and restore solution for PostgreSQL</p> </li> <li> <p>Patroni - an HA (High Availability) solution for PostgreSQL</p> </li> <li> <p>A collection of additional PostgreSQL contrib extensions</p> </li> </ul> <p>Percona Distribution for PostgreSQL is also shipped with the libpq library. It contains \u201ca set of library functions that allow client programs to pass queries to the PostgreSQL backend server and to receive the results of these queries.\u201d </p> <p>This release of Percona Distribution for PostgreSQL is based on PostgreSQL 12.3.</p>"},{"location":"release-notes-v12.4.html","title":"Percona Distribution for PostgreSQL 12.4 (2020-09-11)","text":"Date: September 11, 2020 Installation: Installing Percona Distribution for PostgreSQL <p>Percona Distribution for PostgreSQL is a collection of tools to assist you in managing PostgreSQL. Percona Distribution for PostgreSQL installs PostgreSQL and complements it by a selection of extensions that enable solving essential practical tasks efficiently:</p> Extension Version Description pg_repack 1.4.5 rebuilds PostgreSQL database objects Pgaudit 1.4.0 provides detailed session or object audit logging via the standard logging facility provided by PostgreSQL pgBackRest 2.29 a backup and restore solution for PostgreSQL Patroni 2.0.0 a HA (High Availability) solution for PostgreSQL PostgreSQL contrib extensions 12.4 a collection of additional extensions for PostgreSQL <p>Percona Distribution for PostgreSQL is also shipped with the libpq library. It contains \u201ca set of library functions that allow client programs to pass queries to the PostgreSQL backend server and to receive the results of these queries.\u201d </p> <p>This release of Percona Distribution for PostgreSQL is based on PostgreSQL 12.4.</p>"},{"location":"release-notes-v12.4.upd.html","title":"Percona Distribution for PostgreSQL 12.4 Update (2020-09-22)","text":"Date: September 22, 2020 Installation: Installing Percona Distribution for PostgreSQL <p>This update to the Percona Distribution for PostgreSQL provides a technical preview of pg_stat_monitor - the statistics collection tool for PostgreSQL. <code>pg_stat_monitor</code> is included in the set of extensions supplied within Percona Distribution for PostgreSQL.</p> <p>We welcome your feedback on your experience with <code>pg_stat_monitor</code> in the public JIRA project.</p>"},{"location":"release-notes-v12.5.html","title":"Percona Distribution for PostgreSQL 12.5 (2020-12-07)","text":"Date: December 7, 2020 Installation: Installing Percona Distribution for PostgreSQL <p>Percona Distribution for PostgreSQL is a collection of tools to assist you in managing PostgreSQL. Percona Distribution for PostgreSQL installs PostgreSQL and complements it by a selection of extensions that enable solving essential practical tasks efficiently.</p> <p>This release of Percona Distribution for PostgreSQL is based on PostgreSQL 12.5.</p> <p>The following is the list of extensions available in Percona Distribution for PostgreSQL.</p> Extension Version Description pg_repack 1.4.6 rebuilds PostgreSQL database objects Pgaudit 1.4.1 provides detailed session or object audit logging via the standard logging facility provided by PostgreSQL pgBackRest 2.30 a backup and restore solution for PostgreSQL Patroni 2.0.1 a HA (High Availability) solution for PostgreSQL pg_stat_monitor (Tech Preview Feature) 0.6.0 collects and aggregates statistics for PostgreSQL and provides histogram information. PostgreSQL contrib extensions 12.5 a collection of additional extensions for PostgreSQL <p>Percona Distribution for PostgreSQL is also shipped with the libpq library. It contains \u201ca set of library functions that allow client programs to pass queries to the PostgreSQL backend server and to receive the results of these queries.\u201d</p>"},{"location":"release-notes-v12.6.html","title":"Percona Distribution for PostgreSQL 12.6 (2021-03-09)","text":"Date: March 9, 2021 Installation: Installing Percona Distribution for PostgreSQL <p>Percona Distribution for PostgreSQL is a collection of tools to assist you in managing PostgreSQL. Percona Distribution for PostgreSQL installs PostgreSQL and complements it by a selection of extensions that enable solving essential practical tasks efficiently.</p> <p>This release of Percona Distribution for PostgreSQL is based on PostgreSQL 12.6.</p> <p>The following is the list of extensions available in Percona Distribution for PostgreSQL.</p> Extension Version Description pg_repack 1.4.6 rebuilds PostgreSQL database objects Pgaudit 1.4.1 provides detailed session or object audit logging via the standard logging facility provided by PostgreSQL pgBackRest 2.30 a backup and restore solution for PostgreSQL Patroni 2.0.1 a HA (High Availability) solution for PostgreSQL pg_stat_monitor (Tech Preview Feature) 0.6.0 collects and aggregates statistics for PostgreSQL and provides histogram information. PostgreSQL contrib extensions 12.6 a collection of additional extensions for PostgreSQL <p>Percona Distribution for PostgreSQL is also shipped with the libpq library. It contains \u201ca set of library functions that allow client programs to pass queries to the PostgreSQL backend server and to receive the results of these queries.\u201d</p>"},{"location":"release-notes-v12.6.upd.html","title":"Percona Distribution for PostgreSQL 12.6 Update (2021-04-12)","text":"Date: April 12, 2021 Installation: Installing Percona Distribution for PostgreSQL <p>This update of Percona Distribution for PostgreSQL includes the latest version of pg_stat_monitor 0.8.1 - the statistics collection tool for PostgreSQL. <code>pg_stat_monitor</code> is available as the Tech Preview Feature  and is supplied in the set of extensions within Percona Distribution for PostgreSQL.</p> <p>We welcome your feedback on your experience with <code>pg_stat_monitor</code> in the public JIRA project.</p>"},{"location":"release-notes-v12.6.upd2.html","title":"Percona Distribution for PostgreSQL 12.6 Second Update (2021-04-27)","text":"Date: April 27, 2021 Installation: Installing Percona Distribution for PostgreSQL <p>This update of Percona Distribution for PostgreSQL includes the set of new extensions which are now supplied with Percona Distribution for PostgreSQL:</p> <ul> <li> <p>PgBouncer 1.15.0 - lightweight connection pooler for PostgreSQL</p> </li> <li> <p>pgAudit set_user 2.0.0 - The PostgreSQL Audit extension (<code>pgaudit</code>) provides detailed session and/or object audit logging via the standard PostgreSQL logging facility. The <code>set_user</code> part of that extension provides an additional layer of logging and control when unprivileged users must escalate themselves to superuser or object owner roles in order to perform needed maintenance tasks.</p> </li> <li> <p>pgBadger 11.5 - a fast PostgreSQL Log Analyzer.</p> </li> <li> <p>wal2json 2.3 - a PostgreSQL logical decoding JSON output plugin.</p> </li> </ul> <p>This update of Percona Distribution for PostgreSQL also includes the updated version of Patroni 2.0.2 - a HA (High Availability) solution for PostgreSQL.</p>"},{"location":"release-notes-v12.6.upd3.html","title":"Percona Distribution for PostgreSQL 12.6 Third Update (2021-05-10)","text":"Date: May 10, 2021 Installation: Installing Percona Distribution for PostgreSQL <p>This update of Percona Distribution for PostgreSQL includes the latest version of pg_stat_monitor 0.9.0 - the statistics collection tool for PostgreSQL. <code>pg_stat_monitor</code> is available as the Tech Preview Feature  and is supplied in the set of extensions within Percona Distribution for PostgreSQL.</p> <p>We welcome your feedback on your experience with <code>pg_stat_monitor</code> in the public JIRA project.</p>"},{"location":"release-notes-v12.6.upd4.html","title":"Percona Distribution for PostgreSQL 12.6 Fourth Update (2021-06-10)","text":"Date: June 10, 2021 Installation: Installing Percona Distribution for PostgreSQL <p>This update of Percona Distribution for PostgreSQL includes <code>llvm</code> packages for  Red Hat Enterprise Linux 8 / CentOS 8. This fixes compatibility issues with LLVM from upstream. To use <code>llvm</code> packages supplied by us, disable the upstream <code>llvm-toolset</code> module before the installation:</p> <pre><code>sudo dnf module disable llvm-toolset\n</code></pre>"},{"location":"release-notes-v12.7.html","title":"Percona Distribution for PostgreSQL 12.7 (2021-05-24)","text":"Date: May 24, 2021 Installation: Installing Percona Distribution for PostgreSQL <p>Percona Distribution for PostgreSQL is a collection of tools to assist you in managing PostgreSQL. Percona Distribution for PostgreSQL installs PostgreSQL and complements it by a selection of extensions that enable solving essential practical tasks efficiently.</p> <p>This release of Percona Distribution for PostgreSQL is based on PostgreSQL 12.7.</p> <p>The following is the list of extensions available in Percona Distribution for PostgreSQL.</p> Extension Version Description pg_repack 1.4.6 rebuilds PostgreSQL database objects pgAudit 1.4.1 provides detailed session or object audit logging via the standard logging facility provided by PostgreSQL pgAudit set_user 2.0.0 provides an additional layer of logging and control when unprivileged users must escalate themselves to superuser or object owner roles in order to perform needed maintenance tasks. pgBackRest 2.33 a backup and restore solution for PostgreSQL Patroni 2.0.2 a HA (High Availability) solution for PostgreSQL pg_stat_monitor (Tech Preview Feature) 0.9.1 collects and aggregates statistics for PostgreSQL and provides histogram information. PgBouncer 1.15.0 a lightweight connection pooler for PostgreSQL pgBadger 11.5 a fast PostgreSQL Log Analyzer wal2json 2.3 a PostgreSQL logical decoding JSON output plugin. PostgreSQL contrib extensions 12.7 a collection of additional extensions for PostgreSQL <p>Percona Distribution for PostgreSQL is also shipped with the libpq library. It contains \u201ca set of library functions that allow client programs to pass queries to the PostgreSQL backend server and to receive the results of these queries.\u201d</p>"},{"location":"release-notes-v12.7.upd.html","title":"Percona Distribution for PostgreSQL 12.7 Update (2021-06-10)","text":"Date: June 10, 2021 Installation: Installing Percona Distribution for PostgreSQL <p>This update of Percona Distribution for PostgreSQL includes the following fixes for Red Hat Enterprise Linux 8 / CentOS 8:</p> <ul> <li><code>llvm</code> packages are added to the repository. This fixes compatibility issues with LLVM from upstream. To use <code>llvm</code> packages supplied by us, disable the upstream <code>llvm-toolset</code> module before the installation:</li> </ul> <pre><code>sudo dnf module disable llvm-toolset\n</code></pre> <ul> <li>systemd unit file includes the correct path to Patroni configuration file. </li> <li><code>etcd</code> and <code>python3-python-etcd</code> packages are added as <code>RPM</code> packages to Percona Distribution for PostgreSQL for Red Hat Enterprise Linux / CentOS 8. These packages are used to set up High Availability clusters with Patroni.  For how to set up Patroni clusters, see Patroni documentation </li> </ul>"},{"location":"release-notes-v12.7.upd2.html","title":"Percona Distribution for PostgreSQL 12.7 Second Update (2021-07-01)","text":"Date: July 1, 2021 Installation: Installing Percona Distribution for PostgreSQL <p>With this update of Percona Distribution for PostgreSQL,  <code>etcd</code> package is added as  a <code>DEB</code> package to Percona Distribution for PostgreSQL for Debian 9 (\u201cstretch\u201d). This package is used to set up High Availability clusters with Patroni.  For how to set up Patroni clusters, see Patroni documentation. </p>"},{"location":"release-notes-v12.7.upd3.html","title":"Percona Distribution for PostgreSQL 12.7 Third Update (2021-07-15)","text":"Date: July 15, 2021 Installation: Installing Percona Distribution for PostgreSQL <p>This update of Percona Distribution for PostgreSQL, includes the RPM package for <code>python3-python-etcd</code> for CentOS 7. This package is a Python client for ETCD and is used by Patroni to communicate with  ETCD storage. For how to set up Patroni clusters, see Patroni documentation. </p>"},{"location":"release-notes-v12.8.html","title":"Percona Distribution for PostgreSQL 12.8 (2021-09-09)","text":"Date: September 9, 2021 Installation: Installing Percona Distribution for PostgreSQL <p>Percona Distribution for PostgreSQL is a collection of tools to assist you in managing PostgreSQL. Percona Distribution for PostgreSQL installs PostgreSQL and complements it by a selection of extensions that enable solving essential practical tasks efficiently.</p> <p>This release of Percona Distribution for PostgreSQL is based on PostgreSQL 12.8.</p> <p>The following is the list of extensions available in Percona Distribution for PostgreSQL.</p> Extension Version Description Patroni 2.1.0 a HA (High Availability) solution for PostgreSQL pgAudit 1.4.1 provides detailed session or object audit logging via the standard logging facility provided by PostgreSQL pgAudit set_user 2.0.1 provides an additional layer of logging and control when unprivileged users must escalate themselves to superuser or object owner roles in order to perform needed maintenance tasks. pgBackRest 2.34 a backup and restore solution for PostgreSQL pgBadger 11.5 a fast PostgreSQL Log Analyzer PgBouncer 1.16.0 a lightweight connection pooler for PostgreSQL pg_repack 1.4.6 rebuilds PostgreSQL database objects pg_stat_monitor 0.9.2 - Beta1 collects and aggregates statistics for PostgreSQL and provides histogram information. wal2json 2.3 a PostgreSQL logical decoding JSON output plugin. <p>Percona Distribution for PostgreSQL also includes the ETCD packages which are used for Patroni cluster setup. These packages are available for the following operating systems:</p> Operating System Package Description CentOS 7 <code>python3-python-etcd</code> A Python client for ETCD CentOS 8 <code>etcd</code> A consistent, distributed key-value store <code>python3-python-etcd</code> A Python client for ETCD Debian 9 (\u2018stretch\u2019) <code>etcd</code> A consistent, distributed key-value store <code>python3-etcd</code> A Python client for ETCD <p>Percona Distribution for PostgreSQL is also shipped with the libpq library. It contains \u201ca set of library functions that allow client programs to pass queries to the PostgreSQL backend server and to receive the results of these queries.\u201d 1</p> <ol> <li> <p>https://www.postgresql.org/docs/12/libpq.html\u00a0\u21a9</p> </li> </ol>"},{"location":"release-notes-v12.8.upd.html","title":"Percona Distribution for PostgreSQL 12.8 Update (2021-12-07)","text":"Date: December 7, 2021 Installation: Installing Percona Distribution for PostgreSQL <p>Percona Distribution for PostgreSQL is a collection of tools to assist you in managing PostgreSQL. Percona Distribution for PostgreSQL installs PostgreSQL and complements it by a selection of extensions that enable solving essential practical tasks efficiently.</p> <p>This update of Percona Distribution for PostgreSQL includes the new version of pg_stat_monitor 1.0.0-RC - the statistics collection tool for PostgreSQL.</p> <p>We welcome your feedback on your experience with <code>pg_stat_monitor</code> in the public JIRA project.</p>"},{"location":"release-notes-v12.9.html","title":"Percona Distribution for PostgreSQL 12.9 (2021-12-13)","text":"Date: December 13, 2021 Installation: Installing Percona Distribution for PostgreSQL <p>Percona Distribution for PostgreSQL is a collection of tools to assist you in managing PostgreSQL. Percona Distribution for PostgreSQL installs PostgreSQL and complements it by a selection of extensions that enable solving essential practical tasks efficiently.</p> <p>This release of Percona Distribution for PostgreSQL is based on PostgreSQL 12.9.</p> <p>The following is the list of extensions available in Percona Distribution for PostgreSQL.</p> Extension Version Description Patroni 2.1.1 a HA (High Availability) solution for PostgreSQL pgAudit 1.4.1 provides detailed session or object audit logging via the standard logging facility provided by PostgreSQL pgAudit set_user 3.0.0 provides an additional layer of logging and control when unprivileged users must escalate themselves to superuser or object owner roles in order to perform needed maintenance tasks. pgBackRest 2.36 a backup and restore solution for PostgreSQL pgBadger 11.6 a fast PostgreSQL Log Analyzer PgBouncer 1.16.1 a lightweight connection pooler for PostgreSQL pg_repack 1.4.7 rebuilds PostgreSQL database objects pg_stat_monitor 1.0.0 - rc.1 collects and aggregates statistics for PostgreSQL and provides histogram information. PostgreSQL Common 230 PostgreSQL database-cluster manager. It provides a structure under which multiple versions of PostgreSQL may be installed and/or multiple clusters maintained at one time. wal2json 2.4 a PostgreSQL logical decoding JSON output plugin. <p>Percona Distribution for PostgreSQL also includes the following packages:</p> <ul> <li><code>llvm</code> 12.0.1 packages for Red Hat Enterprise Linux 8 / CentOS 8. This fixes compatibility issues with LLVM from upstream.</li> <li>supplemental <code>ETCD</code> packages which can be used for setting up Patroni clusters. These packages are available for the following operating systems:</li> </ul> Operating System Package Version Description CentOS 7 <code>python3-python-etcd</code> 0.4.3 A Python client for ETCD CentOS 8 <code>etcd</code> 3.3.11 A consistent, distributed key-value store <code>python3-python-etcd</code> 0.4.3 A Python client for ETCD Debian 9 (\u2018stretch\u2019) <code>etcd</code> 3.3.11 A consistent, distributed key-value store <code>python3-etcd</code> 0.4.3 A Python client for ETCD <p>Percona Distribution for PostgreSQL is also shipped with the libpq library. It contains \u201ca set of library functions that allow client programs to pass queries to the PostgreSQL backend server and to receive the results of these queries.\u201d </p>"},{"location":"release-notes.html","title":"Release notes index","text":"<ul> <li> <p>Percona Distribution for PostgreSQL 12.13 (2022-12-01)</p> </li> <li> <p>Percona Distribution for PostgreSQL 12.12 (2022-09-07)</p> </li> <li> <p>Percona Distribution for PostgreSQL 12.11 (2022-06-06)</p> </li> <li> <p>Percona Distribution for PostgreSQL 12.10 Second Update (2022-05-05)</p> </li> <li> <p>Percona Distribution for PostgreSQL 12.10 Update (2022-04-14)</p> </li> <li> <p>Percona Distribution for PostgreSQL 12.10 (2022-03-30)</p> </li> <li> <p>Percona Distribution for PostgreSQL 12.9 (2021-12-13)</p> </li> <li> <p>Percona Distribution for PostgreSQL 12.8 Update (2021-12-07)</p> </li> <li> <p>Percona Distribution for PostgreSQL 12.8 (2021-09-09)</p> </li> <li> <p>Percona Distribution for PostgreSQL 12.7 Third Update (2021-07-15)</p> </li> <li> <p>Percona Distribution for PostgreSQL 12.7 Second Update (2021-07-01)</p> </li> <li> <p>Percona Distribution for PostgreSQL 12.7 Update (2021-06-10)</p> </li> <li> <p>Percona Distribution for PostgreSQL 12.7 (2021-05-24)</p> </li> <li> <p>Percona Distribution for PostgreSQL 12.6 Fourth Update (2021-06-10)</p> </li> <li> <p>Percona Distribution for PostgreSQL 12.6 Third Update (2021-05-10)</p> </li> <li> <p>Percona Distribution for PostgreSQL 12.6 Second Update (2021-04-27)</p> </li> <li> <p>Percona Distribution for PostgreSQL 12.6 Update (2021-04-12)</p> </li> <li> <p>Percona Distribution for PostgreSQL 12.6 (2021-03-09)</p> </li> <li> <p>Percona Distribution for PostgreSQL 12.5 (2020-12-07)</p> </li> <li> <p>Percona Distribution for PostgreSQL 12.4 Update (2020-09-22)</p> </li> <li> <p>Percona Distribution for PostgreSQL 12.4 (2020-09-11)</p> </li> <li> <p>Percona Distribution for PostgreSQL 12.3 (2020-06-11)</p> </li> <li> <p>Percona Distribution for PostgreSQL 12.2 (2020-05-15)</p> </li> </ul>"},{"location":"repo-overview.html","title":"Repositories overview","text":"<p>Percona provides two repositories for Percona Distribution for PostgreSQL. </p> Major release repository Minor release repository Major Release repository (e.g. <code>ppg-12</code>) includes the latest version packages. Whenever a package is updated, the package manager of your operating system detects that and prompts you to update. As long as you update all Distribution packages at the same time, you can ensure that the packages you\u2019re using have been tested and verified by Percona.  We recommend installing Percona Distribution for PostgreSQL from the Major Release repository Minor Release repository includes a particular minor release of the database and all of the packages that were tested and verified to work with that minor release (e.g. <code>ppg-12.10</code>). You may choose to install Percona Distribution for PostgreSQL from the Minor Release repository if you have decided to standardize on a particular release which has passed rigorous testing procedures and which has been verified to work with your applications. This allows you to deploy to a new host and ensure that you\u2019ll be using the same version of all the Distribution packages, even if newer releases exist in other repositories.  The disadvantage of using a Minor Release repository is that you are locked in this particular release. When potentially critical fixes are released in a later minor version of the database, you will not be prompted for an upgrade by the package manager of your operating system. You would need to change the configured repository in order to install the upgrade."},{"location":"uninstalling.html","title":"Uninstalling Percona Distribution for PostgreSQL","text":"<p>To uninstall Percona Distribution for PostgreSQL, remove all the installed packages and data / configuration files.</p> <p>NOTE: Should you need the data files later, back up your data before uninstalling Percona Distribution for PostgreSQL.</p> On Debian and Ubuntu using <code>apt</code>On Red Hat Enterprise Linux and derivatives using <code>yum</code> <p>Run all commands as root or via sudo.</p> <ol> <li> <p>Stop the Percona Distribution for PostgreSQL service.</p> <pre><code>$ sudo systemctl stop postgresql.service\n</code></pre> </li> <li> <p>Remove the percona-postgresql packages.</p> <pre><code>$ sudo apt remove percona-postgresql-12* percona-patroni percona-pgbackrest percona-pgbadger percona-pgbouncer\n</code></pre> </li> <li> <p>Remove configuration and data files.</p> <pre><code>$ rm -rf /etc/postgresql/12/main\n</code></pre> </li> </ol> <p>Run all commands as root or via sudo.</p> <ol> <li> <p>Stop the Percona Distribution for PostgreSQL service.</p> <pre><code>$ sudo systemctl stop postgresql-12\n</code></pre> </li> <li> <p>Remove the percona-postgresql packages</p> <pre><code>$ sudo yum remove percona-postgresql12* percona-pgbadger\n</code></pre> </li> <li> <p>Remove configuration and data files</p> <pre><code>$ rm -rf /var/lib/pgsql/12/data\n</code></pre> </li> </ol>"},{"location":"yum.html","title":"Install Percona Distribution for PostgreSQL on Red Hat Enterprise Linux and derivatives","text":"<p>This document describes how to install Percona Server for PostgreSQL from Percona repositories on RPM-based distributions such as Red Hat Enterprise Linux and compatible derivatives..</p>"},{"location":"yum.html#platform-specific-notes","title":"Platform Specific Notes","text":"<p>If you intend to install Percona Distribution for PostgreSQL on Red Hat Enterprise Linux v8, disable the <code>postgresql</code>  and <code>llvm-toolset</code>modules:</p> <pre><code>$ sudo dnf module disable postgresql llvm-toolset\n</code></pre> <p>On CentOS 7, you should install the <code>epel-release</code> package:</p> <pre><code>$ sudo yum -y install epel-release\n$ sudo yum repolist\n</code></pre>"},{"location":"yum.html#procedure","title":"Procedure","text":"<p>Run all the commands in the following sections as root or using the <code>sudo</code> command:</p>"},{"location":"yum.html#configure-the-repository","title":"Configure the repository","text":"<ol> <li> <p>Install the <code>percona-release</code> repository management tool to subscribe to Percona repositories:</p> <pre><code>$ sudo yum install https://repo.percona.com/yum/percona-release-latest.noarch.rpm\n</code></pre> </li> <li> <p>Enable the repository</p> </li> </ol> <p>Percona provides two repositories for Percona Distribution for PostgreSQL. We recommend enabling the Major release repository to timely receive the latest updates. </p> <p>To enable a repository, we recommend using the <code>setup</code> command: </p> <pre><code>$ sudo percona-release setup ppg-12\n</code></pre>"},{"location":"yum.html#install-packages","title":"Install packages","text":"Install using meta-packageInstall packages individually <pre><code>$ sudo yum install percona-ppg-server12\n</code></pre> <ol> <li> <p>Install the PostgreSQL server package:</p> <pre><code>$ sudo yum install percona-postgresql12-server\n</code></pre> </li> <li> <p>Install the components:</p> <p>Install <code>pg_repack</code>:</p> <pre><code>$ sudo yum install percona-pg_repack12\n</code></pre> <p>Install <code>pgaudit</code>:</p> <pre><code>$ sudo yum install percona-pgaudit\n</code></pre> <p>Install <code>pgBackRest</code>:</p> <pre><code>$ sudo yum install percona-pgbackrest\n</code></pre> <p>Install <code>Patroni</code>:</p> <pre><code>$ sudo yum install percona-patroni\n</code></pre> <p>Install <code>pg_stat_monitor</code>:</p> <p>Install <code>pgBouncer</code>:</p> <pre><code>$ sudo yum install percona-pgbouncer\n</code></pre> <p>Install <code>pgAudit-set_user</code>:</p> <pre><code>$ sudo yum install percona-pgaudit12_set_user\n</code></pre> <p>Install <code>pgBadger</code>:</p> <pre><code>$ sudo yum install percona-pgbadger\n</code></pre> <p>Install <code>wal2json</code>:</p> <pre><code>$ sudo yum install percona-wal2json12\n</code></pre> <p>Install PostgreSQL contrib extensions:</p> <pre><code>$ sudo yum install percona-postgresql12-contrib\n</code></pre> <p>Install HAProxy</p> <pre><code>$ sudo yum install percona-haproxy\n</code></pre> <p>Some extensions require additional setup in order to use them with Percona Distribution for PostgreSQL. For more information, refer to Enabling extensions.</p> </li> </ol>"},{"location":"yum.html#start-the-service","title":"Start the service","text":"<p>After the installation, the default database storage is not automatically initialized. To complete the installation and start Percona Distribution for PostgreSQL, initialize the database using the following command:</p> <pre><code>$ /usr/pgsql-12/bin/postgresql-12-setup initdb\n</code></pre> <p>Start the PostgreSQL service:</p> <pre><code>$ sudo systemctl start postgresql-12\n</code></pre>"},{"location":"yum.html#connect-to-the-postgresql-server","title":"Connect to the PostgreSQL server","text":"<p>By default, <code>postgres</code> user and <code>postgres</code> database are created in PostgreSQL upon its installation and initialization. This allows you to connect to the database as the <code>postgres</code> user.</p> <pre><code>$ sudo su postgres\n</code></pre> <p>Open the PostgreSQL interactive terminal:</p> <pre><code>$ psql\n</code></pre> <p>Hint</p> <p>You can connect to <code>psql</code> as the <code>postgres</code> user in one go:</p> <pre><code>$ sudo su postgres psql\n</code></pre> <p>To exit the <code>psql</code> terminal, use the following command:</p> <pre><code>$ \\q\n</code></pre>"},{"location":"solutions/backup-recovery.html","title":"Backup and disaster recovery in Percona Distribution for PostgreSQL","text":"<p>Summary</p> <ul> <li>Overview</li> <li>Architecture</li> <li>Deployment </li> <li>Testing</li> </ul>"},{"location":"solutions/backup-recovery.html#overview","title":"Overview","text":"<p>A Disaster Recovery (DR) solution ensures that a system can be quickly restored to a normal operational state if something unexpected happens. When operating a database, you would back up the data as frequently as possible and have a mechanism to restore that data when needed. Disaster Recovery is often mistaken for high availability (HA), but they are two different concepts altogether:</p> <ul> <li>High availability ensures guaranteed service levels at all times. This solution involves configuring one or more standby systems to an active database, and the ability to switch seamlessly to that standby when the primary database becomes unavailable, for example, during a power outage or a server crash. To learn more about high-availability solutions with Percona Distribution for PostgreSQL, refer to High Availability in PostgreSQL with Patroni.</li> <li>Disaster Recovery protects the database instance against accidental or malicious data loss or data corruption. Disaster recovery can be achieved by using either the options provided by PostgreSQL, or external extensions.</li> </ul> <p></p> PostgreSQL disaster recovery options <p> PostgreSQL offers multiple options for setting up database disaster recovery. </p> <ul> <li>pg_dump or the pg_dumpall utilities</li> </ul> <p>This is the basic backup approach. These tools can generate the backup of one or more PostgreSQL databases (either just the structure, or both the structure and data), then restore them through the pg_restore command. </p> Advantages Disadvantages Easy to use 1. Backup of only one database at a time.2. No incremental backups.3. No point-in-time recovery since the backup is a snapshot in time.4. Performance degradation when the database size is large. <ul> <li>File-based backup and restore</li> </ul> <p>This method involves backing up the PostgreSQL data directory to a different location, and restoring it when needed. </p> Advantages Disadvantages Consistent snapshot of the data directory or the whole data disk volume 1. Requires stopping PostgreSQL in order to copy the files. This is not practical for most production setups. 2. No backup of individual databases or tables. <ul> <li>PostgreSQL pg_basebackup</li> </ul> <p>This backup tool is provided by PostgreSQL. It is used to back up data when the database instance is running. <code>pgasebackup</code> makes a binary copy of the database cluster files, while making sure the system is put in and out of backup mode automatically. </p> Advantages Disadvantages 1. Supports backups when the database is running.2. Supports point-in-time recovery 1. No incremental backups.2. No backup of individual databases or tables. <p></p> <p>To achieve a production grade PostgreSQL disaster recovery solution, you need something that can take full or incremental database backups from a running instance, and restore from those backups at any point in time. Percona Distribution for PostgreSQL is supplied with pgBackRest: a reliable, open-source backup and recovery solution for PostgreSQL.</p> <p>This document focuses on the Disaster recovery solution in Percona Distribution for PostgreSQL. The Deploying backup and disaster recovery solution in Percona Distribution for PostgreSQL tutorial provides guidelines of how to set up and test this solution.</p>"},{"location":"solutions/backup-recovery.html#pgbackrest","title":"pgBackRest","text":"<p>pgBackRest is an easy-to-use, open-source solution that can reliably back up even the largest of PostgreSQL databases. <code>pgBackRest</code> supports the following backup types:</p> <ul> <li>full backup - a complete copy of your entire data set.</li> <li>differential backup - includes all data that has changed since the last full backup. While this means the backup time is slightly higher, it enables a faster restore.</li> <li>incremental backup - only backs up the files that have changed since the last full or differential backup, resulting in a quick backup time. To restore to a point in time, however, you will need to restore each incremental backup in the order they were taken.</li> </ul> <p>When it comes to restoring, <code>pgBackRest</code> can do a full or a delta restore. A full restore needs an empty PostgreSQL target directory. A delta restore is intelligent enough to recognize already-existing files in the PostgreSQL data directory, and update only the ones the backup contains. </p> <p><code>pgBackRest</code> supports remote repository hosting and can even use cloud-based services like AWS S3, Google Cloud Services Cloud Storage, Azure Blob Storage for saving backup files. It supports parallel backup through multi-core processing and compression. By default, backup integrity is verified through checksums, and saved files can be encrypted for enhanced security.</p> <p><code>pgBackRest</code> can restore a database to a specific point in time in the past. This is the case where a database is not inaccessible but perhaps contains corrupted data. Using the point-in-time recovery, a database administrator can restore the database to the last known good state.  </p> <p>Finally, <code>pgBackRest</code> also supports restoring PostgreSQL databases to a different PostgreSQL instance or a separate data directory.</p>"},{"location":"solutions/backup-recovery.html#setup-overview","title":"Setup overview","text":"<p>This section describes the architecture of the backup and disaster recovery solution. For the configuration steps, refer to the Deploying backup and disaster recovery solution in Percona Distribution for PostgreSQL.</p>"},{"location":"solutions/backup-recovery.html#system-architecture","title":"System architecture","text":"<p>As the configuration example, we will use a three server architecture where <code>pgBackRest</code> resides on a dedicated remote host. The servers communicate with each other via passwordless SSH.</p> <p>Important</p> <p>Passwordless SSH may not be an ideal solution for your environment. In this case, consider using other methods, for example, TLS with client certificates.</p> <p>The following diagram illustrates the architecture layout:</p> <p></p>"},{"location":"solutions/backup-recovery.html#components","title":"Components:","text":"<p>The architecture consists of three server instances:</p> <ul> <li><code>pg-primary</code> hosts the primary PostgreSQL server. Note that \u201cprimary\u201d here means the main database instance and does not refer to the primary node of a PostgreSQL replication cluster or a HA setup.</li> <li><code>pg-repo</code> is the remote backup repository and hosts <code>pgBackRest</code>. It\u2019s important to host the backup repository on a physically separate instance, to be accessed when the target goes down. </li> <li><code>pg-secondary</code> is the secondary PostgreSQL node. Don\u2019t confuse it with a hot standby. \u201cSecondary\u201d in this context means a PostgreSQL instance that\u2019s idle. We will restore the database backup to this instance when the primary PostgreSQL instance goes down. </li> </ul> <p>Note</p> <p>For simplicity, we use a single-node PostgreSQL instance as the primary database server. In a production scenario, you will use some form of high-availability solution to protect the primary instance. When you are using a high-availability setup, we recommend configuring <code>pgBackRest</code> to back up the hot standby server so the primary node is not unnecessarily loaded.</p>"},{"location":"solutions/backup-recovery.html#deployment","title":"Deployment","text":"<p>Refer to the Deploying backup and disaster recovery solution in Percona Distribution for PostgreSQL tutorial.  </p>"},{"location":"solutions/dr-pgbackrest-setup.html","title":"Deploying backup and disaster recovery solution in Percona Distribution for PostgreSQL","text":"<p>This document provides instructions of how to set up and test the backup and disaster recovery solution in Percona Distribution for PostgreSQL with <code>pgBackRest</code>. For technical overview and architecture description of this solution, refer to Backup and disaster recovery in Percona Distribution for PostgreSQL.</p>"},{"location":"solutions/dr-pgbackrest-setup.html#deployment","title":"Deployment","text":"<p>As the example configuration, we will use the nodes with the following IP addresses:</p> Node name Internal IP address pg-primary 10.104.0.3 pg-repo 10.104.0.5 pg-secondary 10.104.0.4"},{"location":"solutions/dr-pgbackrest-setup.html#set-up-hostnames","title":"Set up hostnames","text":"<p>In our architecture, the <code>pgBackRest</code> repository is located on a remote host. To allow communication among the nodes, passwordless SSH is required. To achieve this, properly setting up hostnames in the <code>/etc/hosts</code> files is very important.</p> <ol> <li> <p>Define the hostname for every server in the <code>/etc/hostname</code> file. The following are the examples of how the <code>/etc/hostname</code> file in three nodes looks like:</p> <pre><code>cat /etc/hostname\npg-primary\n</code></pre> <pre><code>cat /etc/hostname\npg-repo\n</code></pre> <pre><code>cat /etc/hostname\npg-secondary\n</code></pre> </li> <li> <p>For the nodes to communicate seamlessly across the network, resolve their hostnames to their IP addresses in the <code>/etc/hosts</code> file.  (Alternatively, you can make appropriate entries in your internal DNS servers)</p> </li> </ol> <p>The <code>/etc/hosts</code> file  for the <code>pg-primary node</code> looks like this:</p> <pre><code>```\n127.0.1.1 pg-primary pg-primary\n127.0.0.1 localhost\n10.104.0.5 pg-repo\n```\n</code></pre> <p>The <code>/etc/hosts</code> file in the <code>pg-repo</code> node looks like this:</p> <pre><code>```\n127.0.1.1 pg-repo pg-repo\n127.0.0.1 localhost\n10.104.0.3 pg-primary\n10.104.0.4 pg-secondary\n```\n</code></pre> <p>The <code>/etc/hosts</code> file in the <code>pg-secondary</code> node is shown below:</p> <pre><code>```\n127.0.1.1 pg-secondary pg-secondary\n127.0.0.1 localhost\n10.104.0.3 pg-primary\n10.104.0.5 pg-repo\n```\n</code></pre>"},{"location":"solutions/dr-pgbackrest-setup.html#set-up-passwordless-ssh","title":"Set up passwordless SSH","text":"<p>Before setting up passwordless SSH, ensure that the postgres user in all three instances has a password. </p> <ol> <li> <p>To set or change the password, run the following command as a root user:</p> <pre><code>$ passwd postgres\n</code></pre> </li> <li> <p>Type the new password and confirm it. </p> </li> <li> <p>After setting up the password, edit the <code>/etc/ssh/sshd_config</code> file and ensure the <code>PasswordAuthentication</code> variable is set as <code>yes</code>. </p> <pre><code>PasswordAuthentication yes \n</code></pre> </li> <li> <p>In the <code>pg-repo</code> node, restart the <code>sshd</code> service. Without the restart, the SSH server will not allow you to connect to it using a password while adding the keys.</p> <pre><code>$ sudo service sshd restart\n</code></pre> </li> <li> <p>In the <code>pg-primary</code> node, generate an SSH key pair and add the public key to the <code>pg-repo</code> node. </p> <p>Important</p> <p>Run the commands as the postgres user. </p> <ul> <li> <p>Generate SSH keys:   </p> <pre><code>$ ssh-keygen -t rsa\nGenerating public/private rsa key pair.\nEnter file in which to save the key (/root/.ssh/id_rsa): \nEnter passphrase (empty for no passphrase): \nEnter same passphrase again: \nYour identification has been saved in /root/.ssh/id_rsa\nYour public key has been saved in /root/.ssh/id_rsa.pub\nThe key fingerprint is:\n...\n</code></pre> </li> <li> <p>Copy the public key to the <code>pg-repo</code> node:</p> <pre><code>$ ssh-copy-id -i ~/.ssh/id_rsa.pub postgres@pg-repo\n/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: \"/root/.ssh/id_rsa.pub\"\n/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed\n/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys\npostgres@pg-repo's password: \n\nNumber of key(s) added: 1\n\n\nNow try logging into the machine, with:   \"ssh 'postgres@pg-repo'\"\nand check to make sure that only the key(s) you wanted were added.\n</code></pre> </li> </ul> </li> <li> <p>To verify everything has worked as expected, run the following command from the <code>pg-primary</code> node. </p> <pre><code>$ ssh postgres@pg-repo\n</code></pre> <p>You should be able to connect to the <code>pg-repo</code> terminal without a password.</p> </li> <li> <p>Repeat the SSH connection from <code>pg-repo</code> to <code>pg-primary</code> to ensure that passwordless SSH is working. </p> </li> <li>Set up bidirectional passwordless SSH between <code>pg-repo</code> and <code>pg-secondary</code> using the same method. This will allow <code>pg-repo</code> to recover the backups to <code>pg-secondary</code>. </li> </ol>"},{"location":"solutions/dr-pgbackrest-setup.html#install-percona-distribution-for-postgresql","title":"Install Percona Distribution for PostgreSQL","text":"<p>Install Percona Distribution for PostgreSQL in the primary and the secondary nodes from Percona repository. </p> <ol> <li>Install <code>percona-release</code>.</li> <li> <p>Enable the repository:</p> <pre><code>$ sudo percona-release setup ppg12\n</code></pre> </li> <li> <p>Install Percona Distribution for PostgreSQL packages</p> On Debian and UbuntuOn RedHat Enterprise Linux and derivatives <pre><code>$ sudo apt install percona-postgresql-12 -y\n</code></pre> <pre><code>$ sudo yum install percona-postgresql12-server\n</code></pre> </li> </ol>"},{"location":"solutions/dr-pgbackrest-setup.html#configure-postgresql-on-the-primary-node-for-continuous-backup","title":"Configure PostgreSQL on the primary node for continuous backup","text":"<p>At this step, configure the PostgreSQL instance on the <code>pg-primary</code> node for continuous archiving of the WAL files. </p> <p>Note</p> <p>On Debian and Ubuntu, the path to the configuration file is <code>/etc/postgresql/12/main/postgresql.conf</code>.</p> <p>On RHEL and CentOS, the path to the configuration file is <code>/var/lib/pgsql/12/data/</code>.</p> <ol> <li> <p>Edit the <code>postgresql.conf</code> configuration file to include the following changes:</p> <pre><code>archive_command = 'pgbackrest --stanza=prod_backup archive-push %p'\narchive_mode = on\nlisten_addresses = '*'\nlog_line_prefix = ''\nmax_wal_senders = 3\nwal_level = replica\n</code></pre> </li> <li> <p>Once the changes are saved, restart PostgreSQL.</p> <pre><code>$ sudo systemctl restart postgresql\n</code></pre> </li> </ol>"},{"location":"solutions/dr-pgbackrest-setup.html#install-pgbackrest","title":"Install pgBackRest","text":"<p>Install <code>pgBackRest</code> in all three instances from Percona repository. Use the following command:</p> On Debian / UbuntuOn RHEL / derivatives <pre><code>$ sudo apt-get install percona-pgbackrest\n</code></pre> <pre><code>$ sudo yum install percona-pgbackrest\n</code></pre>"},{"location":"solutions/dr-pgbackrest-setup.html#create-the-pgbackrest-configuration-file","title":"Create the <code>pgBackRest</code> configuration file","text":"<p>Run the following commands on all three nodes to set up the required configuration file for <code>pgBackRest</code>.</p> <ol> <li> <p>Configure a location and permissions for the <code>pgBackRest</code> log rotation:</p> <pre><code>$ sudo mkdir -p -m 770 /var/log/pgbackrest\n$ sudo chown postgres:postgres /var/log/pgbackrest\n</code></pre> </li> <li> <p>Configure the location and permissions for the <code>pgBackRest</code> configuration file:</p> <pre><code>$ sudo mkdir -p /etc/pgbackrest\n$ sudo mkdir -p /etc/pgbackrest/conf.d\n$ sudo touch /etc/pgbackrest/pgbackrest.conf\n$ sudo chmod 640 /etc/pgbackrest/pgbackrest.conf\n$ sudo chown postgres:postgres /etc/pgbackrest/pgbackrest.conf\n$ sudo mkdir -p /home/pgbackrest\n$ sudo chmod postgres:postgres /home/pgbackrest\n</code></pre> </li> </ol>"},{"location":"solutions/dr-pgbackrest-setup.html#update-pgbackrest-configuration-file-in-the-primary-node","title":"Update <code>pgBackRest</code> configuration file in the primary node","text":"<p>Configure <code>pgBackRest</code> on the <code>pg-primary</code> node by setting up a stanza. A stanza is a set of configuration parameters that tells <code>pgBackRest</code> where to backup its files. Edit the <code>/etc/pgbackrest/pgbackrest.conf</code> file in the <code>pg-primary</code> node to include the following lines:</p> <pre><code>[global]\nrepo1-host=pg-repo \nrepo1-host-user=postgres\nprocess-max=2\nlog-level-console=info\nlog-level-file=debug\n\n[prod_backup]\npg1-path=/var/lib/postgresql/12/main\n</code></pre> <p>You can see the <code>pg1-path</code> attribute for the <code>prod_backup</code> stanza has been set to the PostgreSQL data folder.</p>"},{"location":"solutions/dr-pgbackrest-setup.html#update-pgbackrest-configuration-file-in-the-remote-backup-repository-node","title":"Update <code>pgBackRest</code> configuration file in the remote backup repository node","text":"<p>Add a stanza for the <code>pgBackRest</code> in the <code>pg-repo</code> node. Edit the <code>/etc/pgbackrest/pgbackrest.conf</code> configuration file to include the following lines:</p> <pre><code>[global]\nrepo1-path=/home/pgbackrest/pg_backup\nrepo1-retention-full=2\nprocess-max=2\nlog-level-console=info\nlog-level-file=debug\nstart-fast=y\nstop-auto=y\n\n[prod_backup]\npg1-path=/var/lib/postgresql/12/main\npg1-host=pg-primary\npg1-host-user=postgres\npg1-port = 5432\n</code></pre>"},{"location":"solutions/dr-pgbackrest-setup.html#initialize-pgbackrest-stanza-in-the-remote-backup-repository-node","title":"Initialize <code>pgBackRest</code> stanza in the remote backup repository node","text":"<p>After the configuration files are set up, it\u2019s now time to initialize the <code>pgBackRest</code> stanza. Run the following command in the remote backup repository node (<code>pg-repo</code>).</p> <pre><code>$ sudo -u postgres pgbackrest --stanza=prod_backup stanza-create\n2021-11-07 11:08:18.157 P00   INFO: stanza-create command begin 2.36: --exec-id=155883-2277a3e7 --log-level-console=info --log-level-file=off --pg1-host=pg-primary --pg1-host-user=postgres --pg1-path=/var/lib/postgresql/12/main --pg1-port=5432 --repo1-path=/home/pgbackrest/pg_backup --stanza=prod_backup\n2021-11-07 11:08:19.453 P00   INFO: stanza-create for stanza 'prod_backup' on repo1\n2021-11-07 11:08:19.566 P00   INFO: stanza-create command end: completed successfully (1412ms)\n</code></pre> <p>Once the stanza is created successfully, you can try out the different use cases for disaster recovery.</p>"},{"location":"solutions/dr-pgbackrest-setup.html#testing-backup-and-restore-with-pgbackrest","title":"Testing Backup and Restore with <code>pgBackRest</code>","text":"<p>This section covers a few use cases where <code>pgBackRest</code> can back up and restore databases either in the same instance or a different node.</p>"},{"location":"solutions/dr-pgbackrest-setup.html#use-case-1-create-a-backup-with-pgbackrest","title":"Use Case 1: Create a backup with <code>pgBackRest</code>","text":"<ol> <li> <p>To start our testing, let\u2019s create a table in the <code>postgres</code> database in the <code>pg-primary</code> node and add some data.</p> <pre><code>CREATE TABLE CUSTOMER (id integer, name text);\nINSERT INTO CUSTOMER VALUES (1,'john');\nINSERT INTO CUSTOMER VALUES (2,'martha');\nINSERT INTO CUSTOMER VALUES (3,'mary');\n</code></pre> </li> <li> <p>Take a full backup of the database instance. Run the following commands from the <code>pg-repo</code> node:</p> </li> </ol> <pre><code>$ pgbackrest -u postgres  --stanza=prod_backup backup --type=full\n</code></pre> <p>If you want an incremental backup, you can omit the <code>type</code> attribute. By default, <code>pgBackRest</code> always takes an incremental backup except the first backup of the cluster which is always a full backup. </p> <p>If you need a differential backup,  use diff for the <code>type</code> field:</p> <pre><code>$ pgbackrest -u postgres --stanza=prod_backup backup --type=diff\n</code></pre>"},{"location":"solutions/dr-pgbackrest-setup.html#use-case-2-restore-a-postgresql-instance-from-a-full-backup","title":"Use Case 2: Restore a PostgreSQL Instance from a full backup","text":"<p>For testing purposes, let\u2019s \u201cdamage\u201d the PostgreSQL instance. </p> <ol> <li> <p>Run the following command in the <code>pg-primary</code> node to delete the main data directory.</p> <pre><code>$ rm -rf /var/lib/postgresql/12/main/*\n</code></pre> </li> <li> <p>To restore the backup, run the following commands. </p> <ul> <li>Stop the <code>postgresql</code> instance</li> </ul> <pre><code>$ sudo systemctl stop postgresql\n</code></pre> <ul> <li>Restore the backup:</li> </ul> <pre><code>$ pgbackrest -u postgres --stanza=prod_backup restore\n</code></pre> <ul> <li>Start the <code>postgresql</code> instance</li> </ul> <pre><code>$ sudo systemctl start postgresql\n</code></pre> </li> <li> <p>After the command executes successfully, you can access PostgreSQL from the <code>psql</code> command line tool and check if the table and data rows have been restored.</p> </li> </ol>"},{"location":"solutions/dr-pgbackrest-setup.html#use-case-3-point-in-time-recovery","title":"Use Case 3: Point-In-Time Recovery","text":"<p>If your target PostgreSQL instance has an already existing data directory, the full restore option will fail. You will get an error message stating there are existing data files.  In this case, you can use the <code>--delta</code> option to restore only the corrupted files. </p> <p>For example, let\u2019s say one of your developers mistakenly deleted a few rows from a table. You can use <code>pgBackRest</code> to revert your database to a previous point in time to recover the lost rows.</p> <p>To test this use case, do the following:</p> <ol> <li> <p>Take a timestamp when the database is stable and error-free. Run the following command from the <code>psql</code>prompt.</p> <pre><code>SELECT CURRENT_TIMESTAMP;\ncurrent_timestamp       -------------------------------\n2021-11-07 11:55:47.952405+00\n(1 row)\n</code></pre> <p>Note down the above timestamp since we will use this time in the restore command. Note that in a real life scenario, finding the correct point in time when the database was error-free may require extensive investigation. It is also important to note that all changes after the selected point will be lost after the roll back. </p> </li> <li> <p>Delete one of the customer records added before.</p> <pre><code>DELETE FROM CUSTOMER WHERE ID=3;\n</code></pre> </li> <li> <p>To recover the data, run a command with the noted timestamp as an argument. Run the commands below to recover the database up to that time.</p> <ul> <li>Stop the <code>postgresql</code> instance</li> </ul> <pre><code>$ sudo systemctl stop postgresql\n</code></pre> <ul> <li>Restore the backup</li> </ul> <pre><code>$ pgbackrest -u postgres --stanza=prod_backup --delta \\\n--type=time \"--target= 2021-11-07 11:55:47.952405+00\" \\\n--target-action=promote restore\n</code></pre> <ul> <li>Start the <code>postgresql</code> instance</li> </ul> <pre><code>$ sudo systemctl start postgresql\n</code></pre> </li> <li> <p>Check the database table to see if the record has been restored.</p> <pre><code>SELECT * from customer;\nid |  name  ----+--------\n1 | john\n2 | martha\n3 | mary\n(3 rows)\n</code></pre> </li> </ol>"},{"location":"solutions/dr-pgbackrest-setup.html#use-case-4-restoring-to-a-separate-postgresql-instance","title":"Use Case 4: Restoring to a Separate PostgreSQL Instance","text":"<p>Sometimes a PostgreSQL server may encounter hardware issues and become completely inaccessible. In such cases, we will need to recover the database to a separate instance where <code>pgBackRest</code> is not initially configured. To restore the instance to a separate host, you have to first install both PostgreSQL and <code>pgBackRest</code> in this host. </p> <p>In our test setup, we already have PostgreSQL and <code>pgBackRest</code> installed in the third node, <code>pg-secondary</code>. Change the <code>pgBackRest</code> configuration file in the <code>pg-secondary</code> node as shown below.</p> <pre><code>[global]\nrepo1-host=pg-repo\nrepo1-host-user=postgres\nprocess-max=2\nlog-level-console=info\nlog-level-file=debug\n\n[prod_backup]\npg1-path=/var/lib/postgresql/12/main\n</code></pre> <p>There should be bidirectional passwordless SSH communication between <code>pg-repo</code> and <code>pg-secondary</code>. Refer to the Set up passwordless SSH section for the steps, if you haven\u2019t configured it. </p> <p>Stop the PostgreSQL instance</p> <pre><code>$ sudo systemctl stop postgresql\n</code></pre> <p>Restore the database backup from <code>pg-repo</code> to <code>pg-secondary</code>.</p> <pre><code>$ pgbackrest -u postgres --stanza=prod_backup --delta restore\n\n2021-11-07 13:34:08.897 P00   INFO: restore command begin 2.36: --delta --exec-id=109728-d81c7b0b --log-level-console=info --log-level-file=debug --pg1-path=/var/lib/postgresql/12/main --process-max=2 --repo1-host=pg-repo --repo1-host-user=postgres --stanza=prod_backup\n2021-11-07 13:34:09.784 P00   INFO: repo1: restore backup set 20211107-111534F_20211107-131807I, recovery will start at 2021-11-07 13:18:07\n2021-11-07 13:34:09.786 P00   INFO: remove invalid files/links/paths from '/var/lib/postgresql/12/main'\n2021-11-07 13:34:11.803 P00   INFO: write updated /var/lib/postgresql/12/main/postgresql.auto.conf\n2021-11-07 13:34:11.819 P00   INFO: restore global/pg_control (performed last to ensure aborted restores cannot be started)\n2021-11-07 13:34:11.819 P00   INFO: restore size = 23.2MB, file total = 937\n2021-11-07 13:34:11.820 P00   INFO: restore command end: completed successfully (2924ms)\n</code></pre> <p>After the restore completes successfully, restart PostgreSQL:</p> <pre><code>$ sudo systemctl start postgresql\n</code></pre> <p>Check the database contents from the local <code>psql</code> shell. </p> <pre><code>SELECT * from customer;\nid |  name  ----+--------\n1 | john\n2 | martha\n3 | mary\n(3 rows)\n</code></pre>"},{"location":"solutions/ha-setup-apt.html","title":"Deploying PostgreSQL for high availability with Patroni on Debian or Ubuntu","text":"<p>This guide provides instructions on how to set up a highly available PostgreSQL cluster with Patroni on Debian or Ubuntu. </p>"},{"location":"solutions/ha-setup-apt.html#preconditions","title":"Preconditions","text":"<p>For this setup, we will use the nodes running on Ubuntu 20.04 as the base operating system and having the following IP addresses:</p> Node name Public IP address Internal IP address node1 157.230.42.174 10.104.0.7 node2 68.183.177.183 10.104.0.2 node3 165.22.62.167 10.104.0.8 HAProxy-demo 134.209.111.138 10.104.0.6 <p>Note</p> <p>In a production (or even non-production) setup, the PostgreSQL nodes will be within a private subnet without any public connectivity to the Internet, and the HAProxy will be in a different subnet that allows client traffic coming only from a selected IP range. To keep things simple, we have implemented this architecture in a DigitalOcean VPS environment, and each node can access the other by its internal, private IP. </p>"},{"location":"solutions/ha-setup-apt.html#setting-up-hostnames-in-the-etchosts-file","title":"Setting up hostnames in the <code>/etc/hosts</code> file","text":"<p>To make the nodes aware of each other and allow their seamless communication, resolve their hostnames to their public IP addresses. Modify the <code>/etc/hosts</code> file of each node as follows:</p> node 1 node 2 node 3 <code> 127.0.0.1 localhost node1  10.104.0.7 node1  10.104.0.2 node2 10.104.0.8 node3 </code> <code>127.0.0.1 localhost node2   10.104.0.7 node1  10.104.0.2 node2   10.104.0.8 node3 </code> <code> 127.0.0.1 localhost node3  10.104.0.7 node1 10.104.0.2 node2  10.104.0.8 node3 </code> <p>The <code>/etc/hosts</code> file of the HAProxy-demo node looks like the following:</p> <pre><code>127.0.1.1 HAProxy-demo HAProxy-demo\n127.0.0.1 localhost\n10.104.0.6 HAProxy-demo\n10.104.0.7 node1\n10.104.0.2 node2\n10.104.0.8 node3\n</code></pre>"},{"location":"solutions/ha-setup-apt.html#install-percona-distribution-for-postgresql","title":"Install Percona Distribution for PostgreSQL","text":"<ol> <li> <p>Follow the installation instructions to install Percona Distribution for PostgreSQL on <code>node1</code>, <code>node2</code> and <code>node3</code>.</p> </li> <li> <p>Remove the data directory. Patroni requires a clean environment to initialize a new cluster. Use the following commands to stop the PostgreSQL service and then remove the data directory:</p> </li> </ol> <pre><code>$ sudo systemctl stop postgresql\n$ sudo rm -rf /var/lib/postgresql/12/main\n</code></pre>"},{"location":"solutions/ha-setup-apt.html#configure-etcd-distributed-store","title":"Configure ETCD distributed store","text":"<p>The distributed configuration store helps establish a consensus among nodes during a failover and will manage the configuration for the three PostgreSQL instances. Although Patroni can work with other distributed consensus stores (i.e., Zookeeper, Consul, etc.), the most commonly used one is <code>etcd</code>. </p> <p>The <code>etcd</code> cluster is first started in one node and then the subsequent nodes are added to the first node using the <code>add</code>command. The configuration is stored in the <code>/etc/default/etcd</code> file.</p> <ol> <li> <p>Install <code>etcd</code> on every PostgreSQL node using the following command:</p> <pre><code>$ sudo apt install etcd\n</code></pre> </li> <li> <p>Modify the <code>/etc/default/etcd</code> configuration file on each node.</p> <ul> <li>On <code>node1</code>, add the IP address of <code>node1</code> to the <code>ETCD_INITIAL_CLUSTER</code> parameter. The configuration file looks as follows:</li> </ul> <pre><code>ETCD_NAME=node1\nETCD_INITIAL_CLUSTER=\"node1=http://10.104.0.7:2380\"\nETCD_INITIAL_CLUSTER_TOKEN=\"devops_token\"\nETCD_INITIAL_CLUSTER_STATE=\"new\"\nETCD_INITIAL_ADVERTISE_PEER_URLS=\"http://10.104.0.7:2380\"\nETCD_DATA_DIR=\"/var/lib/etcd/postgresql\"\nETCD_LISTEN_PEER_URLS=\"http://10.104.0.7:2380\"\nETCD_LISTEN_CLIENT_URLS=\"http://10.104.0.7:2379,http://localhost:2379\"\nETCD_ADVERTISE_CLIENT_URLS=\"http://10.104.0.7:2379\"\n\u2026\n</code></pre> <ul> <li>On <code>node2</code>, add the IP addresses of both <code>node1</code> and <code>node2</code> to the <code>ETCD_INITIAL_CLUSTER</code> parameter:</li> </ul> <pre><code>ETCD_NAME=node2\nETCD_INITIAL_CLUSTER=\"node1=http://10.104.0.7:2380,node2=http://10.104.0.2:2380\"\nETCD_INITIAL_CLUSTER_TOKEN=\"devops_token\"\nETCD_INITIAL_CLUSTER_STATE=\"existing\"\nETCD_INITIAL_ADVERTISE_PEER_URLS=\"http://10.104.0.2:2380\"\nETCD_DATA_DIR=\"/var/lib/etcd/postgresql\"\nETCD_LISTEN_PEER_URLS=\"http://10.104.0.2:2380\"\nETCD_LISTEN_CLIENT_URLS=\"http://10.104.0.2:2379,http://localhost:2379\"\nETCD_ADVERTISE_CLIENT_URLS=\"http://10.104.0.2:2379\"\n\u2026\n</code></pre> <ul> <li>On <code>node3</code>, the <code>ETCD_INITIAL_CLUSTER</code> parameter includes the IP addresses of all three nodes:</li> </ul> <pre><code>ETCD_NAME=node3\nETCD_INITIAL_CLUSTER=\"node1=http://10.104.0.7:2380,node2=http://10.104.0.2:2380,node3=http://10.104.0.8:2380\"\nETCD_INITIAL_CLUSTER_TOKEN=\"devops_token\"\nETCD_INITIAL_CLUSTER_STATE=\"existing\"\nETCD_INITIAL_ADVERTISE_PEER_URLS=\"http://10.104.0.8:2380\"\nETCD_DATA_DIR=\"/var/lib/etcd/postgresql\"\nETCD_LISTEN_PEER_URLS=\"http://10.104.0.8:2380\"\nETCD_LISTEN_CLIENT_URLS=\"http://10.104.0.8:2379,http://localhost:2379\"\nETCD_ADVERTISE_CLIENT_URLS=\"http://10.104.0.8:2379\"\n\u2026\n</code></pre> </li> <li> <p>On <code>node1</code>, add <code>node2</code> and <code>node3</code> to the cluster using the <code>add</code> command:</p> <pre><code>$ sudo etcdctl member add node2 http://10.104.0.2:2380\n$ sudo etcdctl member add node3 http://10.104.0.8:2380\n</code></pre> </li> <li> <p>Restart the <code>etcd</code> service on <code>node2</code> and <code>node3</code>:</p> <pre><code>$ sudo systemctl restart etcd\n</code></pre> </li> <li> <p>Check the etcd cluster members.</p> <pre><code>$ sudo etcdctl member list\n</code></pre> <p>The output resembles the following:</p> <pre><code>21d50d7f768f153a: name=node1 peerURLs=http://10.104.0.7:2380 clientURLs=http://10.104.0.7:2379 isLeader=true\naf4661d829a39112: name=node2 peerURLs=http://10.104.0.2:2380 clientURLs=http://10.104.0.2:2379 isLeader=false\ne3f3c0c1d12e9097: name=node3 peerURLs=http://10.104.0.8:2380 clientURLs=http://10.104.0.8:2379 isLeader=false\n</code></pre> </li> </ol>"},{"location":"solutions/ha-setup-apt.html#set-up-the-watchdog-service","title":"Set up the watchdog service","text":"<p>The Linux kernel uses the utility called a watchdog to protect against an unresponsive system. The watchdog monitors a system for unrecoverable application errors, depleted system resources, etc., and initiates a reboot to safely return the system to a working state. The watchdog functionality is  useful for servers that are intended to run without human intervention for a long time. Instead of users finding a hung server, the watchdog functionality can help maintain the service.</p> <p>In this example, we will configure Softdog - a standard software implementation for watchdog that is shipped with Ubuntu 20.04. </p> <p>Complete the following steps on all three PostgreSQL nodes to load and configure Softdog.  </p> <ol> <li> <p>Load Softdog:</p> <pre><code>$ sudo sh -c 'echo \"softdog\" &gt;&gt; /etc/modules'\n</code></pre> </li> <li> <p>Patroni will be interacting with the watchdog service. Since Patroni is run by the <code>postgres</code> user, this user must have access to Softdog. To make this happen, change the ownership  of the <code>watchdog.rules</code> file to the <code>postgres</code> user: </p> <pre><code>$ sudo sh -c 'echo \"KERNEL==\\\"watchdog\\\", OWNER=\\\"postgres\\\", GROUP=\\\"postgres\\\"\" &gt;&gt; /etc/udev/rules.d/61-watchdog.rules'\n</code></pre> </li> <li> <p>Remove Softdog from the blacklist. </p> <ul> <li>Find out the files where Softdog is blacklisted:</li> </ul> <pre><code>$ grep blacklist /lib/modprobe.d/* /etc/modprobe.d/* |grep softdog\n</code></pre> <p>In our case, <code>modprobe</code>is blacklisting the Softdog:</p> <pre><code>/lib/modprobe.d/blacklist_linux_5.4.0-73-generic.conf:blacklist softdog\n</code></pre> <ul> <li>Remove the <code>blacklist softdog</code> line from the <code>/lib/modprobe.d/blacklist_linux_5.4.0-73-generic.conf</code> file. </li> <li>Restart the service </li> </ul> <pre><code>$ sudo modprobe softdog\n</code></pre> <ul> <li>Verify the <code>modprobe</code> is working correctly by running the <code>lsmod</code>command:</li> </ul> <pre><code>$ sudo lsmod | grep softdog\n</code></pre> <p>The output will show a process identifier if it\u2019s running.</p> <pre><code>softdog                16384  0\n</code></pre> </li> <li> <p>Check that the Softdog files under the <code>/dev/</code>folder are owned by the <code>postgres</code>user: </p> </li> </ol> <pre><code>$ ls -l /dev/watchdog*\n\ncrw-rw---- 1 postgres postgres  10, 130 Sep 11 12:53 /dev/watchdog\ncrw------- 1 root     root     245,   0 Sep 11 12:53 /dev/watchdog0\n</code></pre> <p>Tip</p> <p>If the ownership has not been changed for any reason, run the following command to manually change it:</p> <pre><code>$ sudo chown postgres:postgres /dev/watchdog*\n</code></pre>"},{"location":"solutions/ha-setup-apt.html#configure-patroni","title":"Configure Patroni","text":"<ol> <li> <p>Install Patroni on every PostgreSQL node:</p> <pre><code>$ sudo apt install percona-patroni\n</code></pre> </li> <li> <p>Create the <code>patroni.yml</code> configuration file under the <code>/etc/patroni</code> directory.  The file holds the default configuration values for a PostgreSQL cluster and will reflect the current cluster setup.</p> </li> <li> <p>Add the following configuration for <code>node1</code>:</p> <pre><code>scope: stampede1\nname: node1\n\nrestapi:\nlisten: 0.0.0.0:8008\nconnect_address: node1:8008\n\netcd:\nhost: node1:2379\n\nbootstrap:\n# this section will be written into Etcd:/&lt;namespace&gt;/&lt;scope&gt;/config after initializing new cluster\ndcs:\nttl: 30\nloop_wait: 10\nretry_timeout: 10\nmaximum_lag_on_failover: 1048576\n#    primary_start_timeout: 300\n#    synchronous_mode: false\npostgresql:\nuse_pg_rewind: true\nuse_slots: true\nparameters:\nwal_level: replica\nhot_standby: \"on\"\nlogging_collector: 'on'\nmax_wal_senders: 5\nmax_replication_slots: 5\nwal_log_hints: \"on\"\n#archive_mode: \"on\"\n#archive_timeout: 600\n#archive_command: \"cp -f %p /home/postgres/archived/%f\"\n#recovery_conf:\n#restore_command: cp /home/postgres/archived/%f %p\n\n# some desired options for 'initdb'\ninitdb:  # Note: It needs to be a list (some options need values, others are switches)\n- encoding: UTF8\n- data-checksums\n\npg_hba:  # Add following lines to pg_hba.conf after running 'initdb'\n- host all all 10.104.0.7/32 md5\n- host replication replicator 127.0.0.1/32 trust\n- host all all 10.104.0.2/32 md5  - host all all 10.104.0.8/32 md5 - host all all 10.104.0.6/32 trust\n#  - hostssl all all 0.0.0.0/0 md5\n\n# Additional script to be launched after initial cluster creation (will be passed the connection URL as parameter)\n# post_init: /usr/local/bin/setup_cluster.sh\n# Some additional users users which needs to be created after initializing new cluster\nusers:\nadmin:\npassword: admin\noptions:\n- createrole\n- createdb\nreplicator: password: password    options:\n- replication postgresql:\nlisten: 0.0.0.0:5432\nconnect_address: node1:5432\ndata_dir: \"/var/lib/postgresql/12/main\"\nbin_dir: \"/usr/lib/postgresql/12/bin\"\n#  config_dir:\npgpass: /tmp/pgpass0\nauthentication:\nreplication:\nusername: replicator\npassword: password\nsuperuser:\nusername: postgres\npassword: password\nparameters:\nunix_socket_directories: '/var/run/postgresql'\n\nwatchdog:\nmode: required # Allowed values: off, automatic, required\ndevice: /dev/watchdog\nsafety_margin: 5\n\ntags:\nnofailover: false\nnoloadbalance: false\nclonefrom: false\nnosync: false\n</code></pre> <p>Patroni configuration file</p> <p>Let\u2019s take a moment to understand the contents of the <code>patroni.yml</code> file. </p> <p>The first section provides the details of the first node (<code>node1</code>) and its connection ports. After that, we have the <code>etcd</code> service and its port details.</p> <p>Following these, there is a <code>bootstrap</code> section that contains the PostgreSQL configurations and the steps to run once the database is initialized. The <code>pg_hba.conf</code> entries specify all the other nodes that can connect to this node and their authentication mechanism. </p> </li> <li> <p>Create the configuration files for <code>node2</code> and <code>node3</code>. Replace the reference to <code>node1</code> with <code>node2</code> and <code>node3</code>, respectively.</p> </li> <li> <p>Enable and restart the patroni service on every node. Use the following commands:</p> <pre><code>$ sudo systemctl enable patroni\n$ sudo systemctl restart patroni\n</code></pre> </li> </ol> <p>When Patroni starts, it initializes PostgreSQL (because the service is not currently running and the data directory is empty) following the directives in the bootstrap section of the configuration file. </p> <p>Troubleshooting Patroni</p> <p>To ensure that Patroni has started properly, check the logs using the following command:</p> <pre><code>$ sudo journalctl -u patroni.service -n 100 -f\n</code></pre> <p>The output shouldn\u2019t show any errors:</p> <pre><code>\u2026\n\nSep 23 12:50:21 node01 systemd[1]: Started PostgreSQL high-availability manager.\nSep 23 12:50:22 node01 patroni[10119]: 2021-09-23 12:50:22,022 INFO: Selected new etcd server http://10.104.0.2:2379\nSep 23 12:50:22 node01 patroni[10119]: 2021-09-23 12:50:22,029 INFO: No PostgreSQL configuration items changed, nothing to reload.\nSep 23 12:50:22 node01 patroni[10119]: 2021-09-23 12:50:22,168 INFO: Lock owner: None; I am node1\nSep 23 12:50:22 node01 patroni[10119]: 2021-09-23 12:50:22,177 INFO: trying to bootstrap a new cluster\nSep 23 12:50:22 node01 patroni[10140]: The files belonging to this database system will be owned by user \"postgres\".\nSep 23 12:50:22 node01 patroni[10140]: This user must also own the server process.\nSep 23 12:50:22 node01 patroni[10140]: The database cluster will be initialized with locale \"C.UTF-8\".\nSep 23 12:50:22 node01 patroni[10140]: The default text search configuration will be set to \"english\".\nSep 23 12:50:22 node01 patroni[10140]: Data page checksums are enabled.\nSep 23 12:50:22 node01 patroni[10140]: creating directory /var/lib/postgresql/12/main ... ok\nSep 23 12:50:22 node01 patroni[10140]: creating subdirectories ... ok\nSep 23 12:50:22 node01 patroni[10140]: selecting dynamic shared memory implementation ... posix\nSep 23 12:50:22 node01 patroni[10140]: selecting default max_connections ... 100\nSep 23 12:50:22 node01 patroni[10140]: selecting default shared_buffers ... 128MB\nSep 23 12:50:22 node01 patroni[10140]: selecting default time zone ... Etc/UTC\nSep 23 12:50:22 node01 patroni[10140]: creating configuration files ... ok\nSep 23 12:50:22 node01 patroni[10140]: running bootstrap script ... ok\nSep 23 12:50:23 node01 patroni[10140]: performing post-bootstrap initialization ... ok\nSep 23 12:50:23 node01 patroni[10140]: syncing data to disk ... ok\nSep 23 12:50:23 node01 patroni[10140]: initdb: warning: enabling \"trust\" authentication for local connections\nSep 23 12:50:23 node01 patroni[10140]: You can change this by editing pg_hba.conf or using the option -A, or\nSep 23 12:50:23 node01 patroni[10140]: --auth-local and --auth-host, the next time you run initdb.\nSep 23 12:50:23 node01 patroni[10140]: Success. You can now start the database server using:\nSep 23 12:50:23 node01 patroni[10140]:     /usr/lib/postgresql/12/bin/pg_ctl -D /var/lib/postgresql/12/main -l logfile start\nSep 23 12:50:23 node01 patroni[10156]: 2021-09-23 12:50:23.672 UTC [10156] LOG:  redirecting log output to logging collector process\nSep 23 12:50:23 node01 patroni[10156]: 2021-09-23 12:50:23.672 UTC [10156] HINT:  Future log output will appear in directory \"log\".\nSep 23 12:50:23 node01 patroni[10119]: 2021-09-23 12:50:23,694 INFO: postprimary pid=10156\nSep 23 12:50:23 node01 patroni[10165]: localhost:5432 - accepting connections\nSep 23 12:50:23 node01 patroni[10167]: localhost:5432 - accepting connections\nSep 23 12:50:23 node01 patroni[10119]: 2021-09-23 12:50:23,743 INFO: establishing a new patroni connection to the postgres cluster\nSep 23 12:50:23 node01 patroni[10119]: 2021-09-23 12:50:23,757 INFO: running post_bootstrap\nSep 23 12:50:23 node01 patroni[10119]: 2021-09-23 12:50:23,767 INFO: Software Watchdog activated with 25 second timeout, timing slack 15 seconds\nSep 23 12:50:23 node01 patroni[10119]: 2021-09-23 12:50:23,793 INFO: initialized a new cluster\nSep 23 12:50:33 node01 patroni[10119]: 2021-09-23 12:50:33,810 INFO: no action. I am (node1) the leader with the lock\nSep 23 12:50:33 node01 patroni[10119]: 2021-09-23 12:50:33,899 INFO: no action. I am (node1) the leader with the lock\nSep 23 12:50:43 node01 patroni[10119]: 2021-09-23 12:50:43,898 INFO: no action. I am (node1) the leader with the lock\nSep 23 12:50:53 node01 patroni[10119]: 2021-09-23 12:50:53,894 INFO: no action. I am (node1) the leader with the \n</code></pre> <p>A common error is Patroni complaining about the lack of proper entries in the pg_hba.conf file. If you see such errors, you must manually add or fix the entries in that file and then restart the service.</p> <p>Changing the patroni.yml file and restarting the service will not have any effect here because the bootstrap section specifies the configuration to apply when PostgreSQL is first started in the node. It will not repeat the process even if the Patroni configuration file is modified and the service is restarted. </p> <p>If Patroni has started properly, you should be able to locally connect to a PostgreSQL node using the following command:</p> <pre><code>$ sudo psql -U postgres\n</code></pre> <p>The command output should be similar to the following </p> <pre><code>psql (12.8)\nType \"help\" for help.\n\npostgres=#\n</code></pre>"},{"location":"solutions/ha-setup-apt.html#configure-haproxy","title":"Configure HAProxy","text":"<p>HAProxy node will accept client connection requests and route those to the active node of the PostgreSQL cluster. This way, a client application doesn\u2019t have to know what node in the underlying cluster is the current primary. All it needs to do is to access a single HAProxy URL and send its read/write requests there. Behind-the-scene, HAProxy routes the connection to a healthy node (as long as there is at least one healthy node available) and ensures that client application requests are never rejected. </p> <p>HAProxy is capable of routing write requests to the primary node and read requests - to the secondaries in a round-robin fashion so that no secondary instance is unnecessarily loaded. To make this happen, provide different ports in the HAProxy configuration file. In this deployment, writes are routed to port 5000 and reads  - to port 5001.</p> <ol> <li> <p>Install HAProxy on the <code>HAProxy-demo</code> node:</p> <pre><code>$ sudo apt install haproxy\n</code></pre> </li> <li> <p>The HAProxy configuration file path is: <code>/etc/haproxy/haproxy.cfg</code>. Specify the following configuration in this file.</p> <pre><code>global\n    maxconn 100\n\ndefaults\n    log global\n    mode tcp\n    retries 2\n    timeout client 30m\n    timeout connect 4s\n    timeout server 30m\n    timeout check 5s\n\nlisten stats\n    mode http\n    bind *:7000\n    stats enable\n    stats uri /\n\nlisten primary\n    bind *:5000\n    option httpchk /primary \n    http-check expect status 200\n    default-server inter 3s fall 3 rise 2 on-marked-down shutdown-sessions\n    server node1 node1:5432 maxconn 100 check port 8008\n    server node2 node2:5432 maxconn 100 check port 8008\n    server node3 node3:5432 maxconn 100 check port 8008\n\nlisten standbys\n    balance roundrobin\n    bind *:5001\n    option httpchk /replica \n    http-check expect status 200\n    default-server inter 3s fall 3 rise 2 on-marked-down shutdown-sessions\n    server node1 node1:5432 maxconn 100 check port 8008\n    server node2 node2:5432 maxconn 100 check port 8008\n    server node3 node3:5432 maxconn 100 check port 8008\n</code></pre> <p>HAProxy will use the REST APIs hosted by Patroni to check the health status of each PostgreSQL node and route the requests appropriately. </p> </li> <li> <p>Restart HAProxy:</p> <pre><code>$ sudo systemctl restart haproxy\n</code></pre> </li> <li> <p>Check the HAProxy logs to see if there are any errors:</p> <pre><code>$ sudo journalctl -u haproxy.service -n 100 -f\n</code></pre> </li> </ol>"},{"location":"solutions/ha-setup-apt.html#testing","title":"Testing","text":"<p>See the Testing PostgreSQL cluster for the guidelines on how to test your PostgreSQL cluster for replication, failure, switchover.</p>"},{"location":"solutions/ha-setup-yum.html","title":"Deploying PostgreSQL for high availability with Patroni on RHEL or CentOS","text":"<p>This guide provides instructions on how to set up a highly available PostgreSQL cluster with Patroni on Red Hat Enterprise Linux or CentOS. </p>"},{"location":"solutions/ha-setup-yum.html#preconditions","title":"Preconditions","text":"<p>For this setup, we will use the nodes running on CentOS 8 as the base operating system and having the following IP addresses:</p> Hostname Public IP address Internal IP address node1 157.230.42.174 10.104.0.7 node2 68.183.177.183 10.104.0.2 node3 165.22.62.167 10.104.0.8 etcd 159.102.29.166 10.104.0.5 HAProxy-demo 134.209.111.138 10.104.0.6 <p>Note</p> <p>In a production (or even non-production) setup, the PostgreSQL and ETCD nodes will be within a private subnet without any public connectivity to the Internet, and the HAProxy will be in a different subnet that allows client traffic coming only from a selected IP range. To keep things simple, we have implemented this architecture in a DigitalOcean VPS environment, and each node can access the other by its internal, private IP. </p>"},{"location":"solutions/ha-setup-yum.html#setting-up-hostnames-in-the-etchosts-file","title":"Setting up hostnames in the <code>/etc/hosts</code> file","text":"<p>To make the nodes aware of each other and allow their seamless communication, resolve their hostnames to their public IP addresses. Modify the <code>/etc/hosts</code> file of each PostgreSQL node to include the hostnames and IP addresses of the remaining nodes. The following is the <code>/etc/hosts</code> file for <code>node1</code>:</p> <pre><code>127.0.0.1 localhost node1\n10.104.0.7 node1 \n10.104.0.2 node2 \n10.104.0.8 node3\n</code></pre> <p>The <code>/etc/hosts</code> file of the <code>HAProxy-demo</code> node hostnames and IP addresses of all PostgreSQL nodes:</p> <pre><code>127.0.1.1 HAProxy-demo HAProxy-demo\n127.0.0.1 localhost\n10.104.0.6 HAProxy-demo\n10.104.0.7 node1\n10.104.0.2 node2\n10.104.0.8 node3\n</code></pre> <p>Keep the <code>/etc/hosts</code> file of the <code>etcd</code> node unchanged.</p>"},{"location":"solutions/ha-setup-yum.html#configure-etcd-distributed-store","title":"Configure ETCD distributed store","text":"<p>The distributed configuration store helps establish a consensus among nodes during a failover and will manage the configuration for the three PostgreSQL instances. Although Patroni can work with other distributed consensus stores (i.e., Zookeeper, Consul, etc.), the most commonly used one is <code>etcd</code>. </p> <p>In this setup we will configure ETCD on a dedicated  node.</p> <ol> <li> <p>Install <code>etcd</code> on the ETCD node. For CentOS 8, the etcd packages are available from Percona repository:</p> </li> <li> <p>Install <code>percona-release</code>.</p> </li> <li> <p>Enable the repository:</p> <pre><code>$ sudo percona-release setup ppg12\n</code></pre> </li> <li> <p>Install the etcd packages using the following command:</p> <pre><code>$ sudo yum install etcd python3-python-etcd\n</code></pre> </li> <li> <p>Modify the <code>/etc/etcd/etcd.conf</code> configuration file:</p> </li> </ol> <pre><code>[Member]\nETCD_DATA_DIR=\"/var/lib/etcd/default.etcd\"\nETCD_LISTEN_PEER_URLS=\"http://10.104.0.5:2380,http://localhost:2380\" \nETCD_LISTEN_CLIENT_URLS=\"http://10.104.0.5:2379,http://localhost:2379\"\n\n\nETCD_NAME=\"default\"\nETCD_INITIAL_ADVERTISE_PEER_URLS=\"http://10.104.0.5:2380\"\nETCD_ADVERTISE_CLIENT_URLS=\"http://10.104.0.5:2379\"\nETCD_INITIAL_CLUSTER=\"default=http://10.104.0.5:2380\"\nETCD_INITIAL_CLUSTER_TOKEN=\"etcd-cluster\"\nETCD_INITIAL_CLUSTER_STATE=\"new\"\n</code></pre> <ol> <li> <p>Start the <code>etcd</code> to apply the changes:</p> <pre><code>$ sudo systemctl enable etcd\n$ sudo systemctl start etcd\n$ sudo systemctl status etcd\n</code></pre> </li> <li> <p>Check the etcd cluster members.</p> <pre><code>$ sudo etcdctl member list\n</code></pre> <p>The output resembles the following:</p> <pre><code>21d50d7f768f153a: name=default peerURLs=http://10.104.0.5:2380 clientURLs=http://10.104.0.5:2379 isLeader=true\n</code></pre> </li> </ol>"},{"location":"solutions/ha-setup-yum.html#install-percona-distribution-for-postgresql","title":"Install Percona Distribution for PostgreSQL","text":"<p>Install Percona Distribution for PostgreSQL on <code>node1</code>, <code>node2</code> and <code>node3</code> from Percona repository:</p> <ol> <li>Install <code>percona-release</code>.</li> <li> <p>Enable the repository:</p> <pre><code>$ sudo percona-release setup ppg12\n</code></pre> </li> <li> <p>Install Percona Distribution for PostgreSQL packages.</p> </li> </ol> <p>Important</p> <p>Don\u2019t initialize the cluster and start the <code>postgresql</code> service. The cluster initialization and setup are handled by Patroni during the bootsrapping stage.</p>"},{"location":"solutions/ha-setup-yum.html#configure-patroni","title":"Configure Patroni","text":"<ol> <li> <p>Install Patroni on every PostgreSQL node:</p> <pre><code>$ sudo yum install percona-patroni\n</code></pre> </li> <li> <p>Install the Python module that enables Patroni to communicate with ETCD.</p> <pre><code>$ sudo python3 -m pip install patroni[etcd]\n</code></pre> </li> <li> <p>Create the directories required by Patroni</p> <ul> <li>Create the directory to store the configuration file and make it owned by the <code>postgres</code> user.</li> </ul> <pre><code>$ sudo mkdir -p /etc/patroni/\n$ sudo chown -R  postgres:postgres /etc/patroni/\n</code></pre> <ul> <li>Create the data directory for Patroni. Change its ownership to the <code>postgres</code> user and restrict the access to it </li> </ul> <pre><code>$ sudo mkdir /data/patroni -p\n$ sudo chown -R postgres:postgres /data/patroni\n$ sudo chmod 700 /data/patroni\n</code></pre> </li> <li> <p>Create the <code>patroni.yml</code> configuration file. </p> <pre><code>$ su postgres\n$ vim /etc/patroni/patroni.yml\n</code></pre> </li> <li> <p>Specify the following configuration:</p> <pre><code>scope: postgres\nnamespace: /pg_cluster/\nname: node1\n\nrestapi:\nlisten: 10.104.0.7:8008            # PostgreSQL node IP address\nconnect_address: 10.104.0.7:8008   # PostgreSQL node IP address\n\netcd:\nhost: 10.104.0.5:2379  # ETCD node IP address\n\nbootstrap:\n# this section will be written into Etcd:/&lt;namespace&gt;/&lt;scope&gt;/config after initializing new cluster\ndcs:\nttl: 30\nloop_wait: 10\nretry_timeout: 10\nmaximum_lag_on_failover: 1048576\npostgresql:\nuse_pg_rewind: true\nuse_slots: true\nparameters:\nwal_level: replica\nhot_standby: \"on\"\nlogging_collector: 'on'\nmax_wal_senders: 5\nmax_replication_slots: 5\nwal_log_hints: \"on\"\n\n# some desired options for 'initdb'\ninitdb:  # Note: It needs to be a list (some options need values, others are switches)\n- encoding: UTF8\n- data-checksums\n\npg_hba:  # Add following lines to pg_hba.conf after running 'initdb'\n- host replication replicator 127.0.0.1/32 md5\n- host replication replicator 10.104.0.2/32 md5  - host replication replicator 10.104.0.8/32 md5 - host replication replicator 10.104.0.7/32 md5\n- host all all 0.0.0.0/0 md5\n#  - hostssl all all 0.0.0.0/0 md5\n\n# Some additional users users which needs to be created after initializing new cluster\nusers:\nadmin:\npassword: admin\noptions:\n- createrole\n- createdb\n\npostgresql:\nlisten: 10.104.0.7:5432            # PostgreSQL node IP address\nconnect_address: 10.104.0.7:5432   # PostgreSQL node IP address\ndata_dir: /data/patroni            # The datadir you created\nbin_dir: /usr/pgsql-12/bin\npgpass: /tmp/pgpass0\nauthentication:\nreplication:\nusername: replicator\npassword: replicator\nsuperuser:\nusername: postgres\npassword: postgres\nparameters:\nunix_socket_directories: '.'\n\ntags:\nnofailover: false\nnoloadbalance: false\nclonefrom: false\nnosync: false\n</code></pre> </li> <li> <p>Create the configuration files for <code>node2</code> and <code>node3</code>. Replace the node  and IP address of <code>node1</code> to those of <code>node2</code> and <code>node3</code>, respectively.</p> </li> <li> <p>Create the systemd unit file <code>patroni.service</code> in <code>/etc/systemd/system</code>. </p> <pre><code>$ sudo vim /etc/systemd/system/patroni.service\n</code></pre> <p>Add the following contents in the file:</p> <pre><code>[Unit]\nDescription=Runners to orchestrate a high-availability PostgreSQL\nAfter=syslog.target network.target\n\n[Service]\nType=simple\n\nUser=postgres\nGroup=postgres\n\n# Start the patroni process\nExecStart=/bin/patroni /etc/patroni/patroni.yml\n\n# Send HUP to reload from patroni.yml\nExecReload=/bin/kill -s HUP $MAINPID\n\n# only kill the patroni process, not its children, so it will gracefully stop postgres\nKillMode=process\n\n# Give a reasonable amount of time for the server to start up/shut down\nTimeoutSec=30\n\n# Do not restart the service if it crashes, we want to manually inspect database on failure\nRestart=no\n\n[Install]\nWantedBy=multi-user.target\n</code></pre> </li> <li> <p>Make <code>systemd</code> aware of the new service:</p> <pre><code>$ sudo systemctl daemon-reload\n$ sudo systemctl enable patroni\n$ sudo systemctl start patroni\n</code></pre> <p>Troubleshooting Patroni</p> <p>To ensure that Patroni has started properly, check the logs using the following command:</p> <pre><code>$ sudo journalctl -u patroni.service -n 100 -f\n</code></pre> <p>The output shouldn\u2019t show any errors:</p> <pre><code>\u2026\n\nSep 23 12:50:21 node01 systemd[1]: Started PostgreSQL high-availability manager.\nSep 23 12:50:22 node01 patroni[10119]: 2021-09-23 12:50:22,022 INFO: Selected new etcd server http://10.104.0.2:2379\nSep 23 12:50:22 node01 patroni[10119]: 2021-09-23 12:50:22,029 INFO: No PostgreSQL configuration items changed, nothing to reload.\nSep 23 12:50:22 node01 patroni[10119]: 2021-09-23 12:50:22,168 INFO: Lock owner: None; I am node1\nSep 23 12:50:22 node01 patroni[10119]: 2021-09-23 12:50:22,177 INFO: trying to bootstrap a new cluster\nSep 23 12:50:22 node01 patroni[10140]: The files belonging to this database system will be owned by user \"postgres\".\nSep 23 12:50:22 node01 patroni[10140]: This user must also own the server process.\nSep 23 12:50:22 node01 patroni[10140]: The database cluster will be initialized with locale \"C.UTF-8\".\nSep 23 12:50:22 node01 patroni[10140]: The default text search configuration will be set to \"english\".\nSep 23 12:50:22 node01 patroni[10140]: Data page checksums are enabled.\nSep 23 12:50:22 node01 patroni[10140]: creating directory /var/lib/postgresql/12/main ... ok\nSep 23 12:50:22 node01 patroni[10140]: creating subdirectories ... ok\nSep 23 12:50:22 node01 patroni[10140]: selecting dynamic shared memory implementation ... posix\nSep 23 12:50:22 node01 patroni[10140]: selecting default max_connections ... 100\nSep 23 12:50:22 node01 patroni[10140]: selecting default shared_buffers ... 128MB\nSep 23 12:50:22 node01 patroni[10140]: selecting default time zone ... Etc/UTC\nSep 23 12:50:22 node01 patroni[10140]: creating configuration files ... ok\nSep 23 12:50:22 node01 patroni[10140]: running bootstrap script ... ok\nSep 23 12:50:23 node01 patroni[10140]: performing post-bootstrap initialization ... ok\nSep 23 12:50:23 node01 patroni[10140]: syncing data to disk ... ok\nSep 23 12:50:23 node01 patroni[10140]: initdb: warning: enabling \"trust\" authentication for local connections\nSep 23 12:50:23 node01 patroni[10140]: You can change this by editing pg_hba.conf or using the option -A, or\nSep 23 12:50:23 node01 patroni[10140]: --auth-local and --auth-host, the next time you run initdb.\nSep 23 12:50:23 node01 patroni[10140]: Success. You can now start the database server using:\nSep 23 12:50:23 node01 patroni[10140]:     /usr/lib/postgresql/12/bin/pg_ctl -D /var/lib/postgresql/12/main -l logfile start\nSep 23 12:50:23 node01 patroni[10156]: 2021-09-23 12:50:23.672 UTC [10156] LOG:  redirecting log output to logging collector process\nSep 23 12:50:23 node01 patroni[10156]: 2021-09-23 12:50:23.672 UTC [10156] HINT:  Future log output will appear in directory \"log\".\nSep 23 12:50:23 node01 patroni[10119]: 2021-09-23 12:50:23,694 INFO: postprimary pid=10156\nSep 23 12:50:23 node01 patroni[10165]: localhost:5432 - accepting connections\nSep 23 12:50:23 node01 patroni[10167]: localhost:5432 - accepting connections\nSep 23 12:50:23 node01 patroni[10119]: 2021-09-23 12:50:23,743 INFO: establishing a new patroni connection to the postgres cluster\nSep 23 12:50:23 node01 patroni[10119]: 2021-09-23 12:50:23,757 INFO: running post_bootstrap\nSep 23 12:50:23 node01 patroni[10119]: 2021-09-23 12:50:23,767 INFO: Software Watchdog activated with 25 second timeout, timing slack 15 seconds\nSep 23 12:50:23 node01 patroni[10119]: 2021-09-23 12:50:23,793 INFO: initialized a new cluster\nSep 23 12:50:33 node01 patroni[10119]: 2021-09-23 12:50:33,810 INFO: no action. I am (node1) the leader with the lock\nSep 23 12:50:33 node01 patroni[10119]: 2021-09-23 12:50:33,899 INFO: no action. I am (node1) the leader with the lock\nSep 23 12:50:43 node01 patroni[10119]: 2021-09-23 12:50:43,898 INFO: no action. I am (node1) the leader with the lock\nSep 23 12:50:53 node01 patroni[10119]: 2021-09-23 12:50:53,894 INFO: no action. I am (node1) the leader with the \n</code></pre> <p>A common error is Patroni complaining about the lack of proper entries in the pg_hba.conf file. If you see such errors, you must manually add or fix the entries in that file and then restart the service.</p> <p>Changing the patroni.yml file and restarting the service will not have any effect here because the bootstrap section specifies the configuration to apply when PostgreSQL is first started in the node. It will not repeat the process even if the Patroni configuration file is modified and the service is restarted. </p> <p>If Patroni has started properly, you should be able to locally connect to a PostgreSQL node using the following command:</p> <pre><code>$ sudo psql -U postgres\n\npsql (12.3)\nType \"help\" for help.\n\npostgres=#\n</code></pre> </li> <li> <p>Configure, enable and start Patroni on the remaining nodes.</p> </li> <li>When all nodes are up and running, you can check the cluster status using the following command:</li> </ol> <pre><code>$ sudo patronictl -c /etc/patroni/patroni.yml list\n\n\n+ Cluster: postgres (7011110722654005156) -----------+\n| Member | Host  | Role    | State   | TL | Lag in MB |\n+--------+-------+---------+---------+----+-----------+\n| node1  | node1 | Leader  | running |  1 |           |\n| node2  | node2 | Replica | running |  1 |         0 |\n| node3  | node3 | Replica | running |  1 |         0 |\n+--------+-------+---------+---------+----+-----------+\n</code></pre>"},{"location":"solutions/ha-setup-yum.html#configure-haproxy","title":"Configure HAProxy","text":"<p>HAProxy node will accept client connection requests and route those to the active node of the PostgreSQL cluster. This way, a client application doesn\u2019t have to know what node in the underlying cluster is the current primary. All it needs to do is to access a single HAProxy URL and send its read/write requests there. Behind-the-scene, HAProxy routes the connection to a healthy node (as long as there is at least one healthy node available) and ensures that client application requests are never rejected. </p> <p>HAProxy is capable of routing write requests to the primary node and read requests - to the secondaries in a round-robin fashion so that no secondary instance is unnecessarily loaded. To make this happen, provide different ports in the HAProxy configuration file. In this deployment, writes are routed to port 5000 and reads  - to port 5001.</p> <ol> <li> <p>Install HAProxy on the <code>HAProxy-demo</code> node:</p> <pre><code>$ sudo yum install haproxy\n</code></pre> </li> <li> <p>The HAProxy configuration file path is: <code>/etc/haproxy/haproxy.cfg</code>. Specify the following configuration in this file.</p> <pre><code>global\n    maxconn 100\n\ndefaults\n    log global\n    mode tcp\n    retries 2\n    timeout client 30m\n    timeout connect 4s\n    timeout server 30m\n    timeout check 5s\n\nlisten stats\n    mode http\n    bind *:7000\n    stats enable\n    stats uri /\n\nlisten primary\n    bind *:5000\n    option httpchk /primary \n    http-check expect status 200\n    default-server inter 3s fall 3 rise 2 on-marked-down shutdown-sessions\n    server node1 node1:5432 maxconn 100 check port 8008\n    server node2 node2:5432 maxconn 100 check port 8008\n    server node3 node3:5432 maxconn 100 check port 8008\n\nlisten standbys\n    balance roundrobin\n    bind *:5001\n    option httpchk /replica \n    http-check expect status 200\n    default-server inter 3s fall 3 rise 2 on-marked-down shutdown-sessions\n    server node1 node1:5432 maxconn 100 check port 8008\n    server node2 node2:5432 maxconn 100 check port 8008\n    server node3 node3:5432 maxconn 100 check port 8008\n</code></pre> <p>HAProxy will use the REST APIs hosted by Patroni to check the health status of each PostgreSQL node and route the requests appropriately. </p> </li> <li> <p>Enable a SELinux boolean to allow HAProxy to bind to non standard ports:</p> <pre><code>$ sudo setsebool -P haproxy_connect_any on\n</code></pre> </li> <li> <p>Restart HAProxy:</p> <pre><code>$ sudo systemctl restart haproxy\n</code></pre> </li> <li> <p>Check the HAProxy logs to see if there are any errors:</p> <pre><code>$ sudo journalctl -u haproxy.service -n 100 -f\n</code></pre> </li> </ol>"},{"location":"solutions/ha-test.html","title":"Testing the Patroni PostgreSQL Cluster","text":"<p>This document covers the following scenarios to test the PostgreSQL cluster:</p> <ul> <li>replication, </li> <li>connectivity, </li> <li>failover, and </li> <li>manual switchover.</li> </ul>"},{"location":"solutions/ha-test.html#testing-replication","title":"Testing replication","text":"<ol> <li> <p>Connect to the cluster and establish the <code>psql</code> session from a client machine that can connect to the HAProxy node. Use the HAProxy-demo node\u2019s public IP address:</p> <pre><code>$ psql -U postgres -h 134.209.111.138 -p 5000\n</code></pre> </li> <li> <p>Run the following commands to create a table and insert a few rows:</p> <pre><code>CREATE TABLE customer(name text,age integer);\nINSERT INTO CUSTOMER VALUES('john',30);\nINSERT INTO CUSTOMER VALUES('dawson',35);\n</code></pre> </li> <li> <p>To ensure that the replication is working, we can log in to each PostgreSQL node and run a simple SQL statement against the locally running instance:</p> <pre><code>$ sudo psql -U postgres -c \"SELECT * FROM CUSTOMER;\"\n</code></pre> <p>The results on each node should be the following:</p> <pre><code>  name  | age\n--------+-----\n john   |  30\n dawson |  35\n(2 rows)\n</code></pre> </li> </ol>"},{"location":"solutions/ha-test.html#testing-failover","title":"Testing failover","text":"<p>In a proper setup, client applications won\u2019t have issues connecting to the cluster, even if one or even two of the nodes go down. We will test the cluster for failover in the following scenarios:</p>"},{"location":"solutions/ha-test.html#scenario-1-intentionally-stop-the-postgresql-on-the-primary-node-and-verify-access-to-postgresql","title":"Scenario 1. Intentionally stop the PostgreSQL on the primary node and verify access to PostgreSQL.","text":"<ol> <li> <p>Run the following command on any node to check the current cluster status:</p> <pre><code>$ sudo patronictl -c /etc/patroni/patroni.yml list\n\n+ Cluster: stampede1 (7011110722654005156) -----------+\n| Member | Host  | Role    | State   | TL | Lag in MB |\n+--------+-------+---------+---------+----+-----------+\n| node1  | node1 | Leader  | running |  1 |           |\n| node2  | node2 | Replica | running |  1 |         0 |\n| node3  | node3 | Replica | running |  1 |         0 |\n+--------+-------+---------+---------+----+-----------+\n</code></pre> </li> <li> <p><code>node1</code> is the current leader. Stop Patroni in <code>node1</code> to see how it changes the cluster:</p> <pre><code>$ sudo systemctl stop patroni\n</code></pre> </li> <li> <p>Once the service stops in <code>node1</code>, check the logs in <code>node2</code> and <code>node3</code> using the following command: </p> <pre><code>$ sudo journalctl -u patroni.service -n 100 -f\n</code></pre> <p>Output</p> <pre><code>Sep 23 14:18:13 node03 patroni[10042]: 2021-09-23 14:18:13,905 INFO: no action. I am a secondary (node3) and following a leader (node1)\nSep 23 14:18:20 node03 patroni[10042]: 2021-09-23 14:18:20,011 INFO: Got response from node2 http://node2:8008/patroni: {\"state\": \"running\", \"postprimary_start_time\": \"2021-09-23 12:50:29.460027+00:00\", \"role\": \"replica\", \"server_version\": 130003, \"cluster_unlocked\": true, \"xlog\": {\"received_location\": 67219152, \"replayed_location\": 67219152, \"replayed_timestamp\": \"2021-09-23 13:19:50.329387+00:00\", \"paused\": false}, \"timeline\": 1, \"database_system_identifier\": \"7011110722654005156\", \"patroni\": {\"version\": \"2.1.0\", \"scope\": \"stampede1\"}}\nSep 23 14:18:20 node03 patroni[10042]: 2021-09-23 14:18:20,031 WARNING: Request failed to node1: GET http://node1:8008/patroni (HTTPConnectionPool(host='node1', port=8008): Max retries exceeded with url: /patroni (Caused by ProtocolError('Connection aborted.', ConnectionResetError(104, 'Connection reset by peer'))))\nSep 23 14:18:20 node03 patroni[10042]: 2021-09-23 14:18:20,038 INFO: Software Watchdog activated with 25 second timeout, timing slack 15 seconds\nSep 23 14:18:20 node03 patroni[10042]: 2021-09-23 14:18:20,043 INFO: promoted self to leader by acquiring session lock\nSep 23 14:18:20 node03 patroni[13641]: server promoting\nSep 23 14:18:20 node03 patroni[10042]: 2021-09-23 14:18:20,049 INFO: cleared rewind state after becoming the leader\nSep 23 14:18:21 node03 patroni[10042]: 2021-09-23 14:18:21,101 INFO: no action. I am (node3) the leader with the lock\nSep 23 14:18:21 node03 patroni[10042]: 2021-09-23 14:18:21,117 INFO: no action. I am (node3) the leader with the lock\nSep 23 14:18:31 node03 patroni[10042]: 2021-09-23 14:18:31,114 INFO: no action. I am (node3) the leader with the lock\n...\n</code></pre> <p>The logs in <code>node3</code> show that the requests to <code>node1</code> are failing, the watchdog is coming into action, and <code>node3</code> is promoting itself as the leader:</p> </li> <li> <p>Verify that you can still access the cluster through the HAProxy instance and read data:</p> <pre><code>$ psql -U postgres -h 10.104.0.6 -p 5000 -c \"SELECT * FROM CUSTOMER;\"\n\nname  | age\n--------+-----\n john   |  30\ndawson |  35\n(2 rows)\n</code></pre> </li> <li> <p>Restart the Patroni service in <code>node1</code></p> <pre><code>$ sudo systemctl start patroni\n</code></pre> </li> <li> <p>Check the current cluster status:  </p> <pre><code>$ sudo patronictl -c /etc/patroni/patroni.yml list\n\n+ Cluster: stampede1 (7011110722654005156) -----------+\n| Member | Host  | Role    | State   | TL | Lag in MB |\n+--------+-------+---------+---------+----+-----------+\n| node1  | node1 | Replica | running |  2 |         0 |\n| node2  | node2 | Replica | running |  2 |         0 |\n| node3  | node3 | Leader  | running |  2 |           |\n+--------+-------+---------+---------+----+-----------+\n</code></pre> </li> </ol> <p>As we see, <code>node3</code> remains the leader and the rest are replicas.</p>"},{"location":"solutions/ha-test.html#scenario-2-abrupt-machine-shutdown-or-power-outage","title":"Scenario 2. Abrupt machine shutdown or power outage","text":"<p>To emulate the power outage, let\u2019s kill the service in <code>node3</code> and see what happens in <code>node1</code> and <code>node2</code>. </p> <ol> <li> <p>Identify the process ID of Patroni and then kill it with a <code>-9</code> switch. </p> <pre><code>$ ps aux | grep -i patroni\n\npostgres   10042  0.1  2.1 647132 43948 ?        Ssl  12:50   0:09 /usr/bin/python3 /usr/bin/patroni /etc/patroni/patroni.yml\n\n$ sudo kill -9 10042\n</code></pre> </li> <li> <p>Check the logs on <code>node2</code>: </p> <pre><code>$ sudo journalctl -u patroni.service -n 100 -f\n</code></pre> Output <pre><code>Sep 23 14:40:41 node02 patroni[10577]: 2021-09-23 14:40:41,656 INFO: no action. I am a secondary (node2) and following a leader (node3)\n\u2026\nSep 23 14:41:01 node02 patroni[10577]: 2021-09-23 14:41:01,373 INFO: Got response from node1 http://node1:8008/patroni: {\"state\": \"running\", \"postprimary_start_time\": \"2021-09-23 14:25:30.076762+00:00\", \"role\": \"replica\", \"server_version\": 130003, \"cluster_unlocked\": true, \"xlog\": {\"received_location\": 67221352, \"replayed_location\": 67221352, \"replayed_timestamp\": null, \"paused\": false}, \"timeline\": 2, \"database_system_identifier\": \"7011110722654005156\", \"patroni\": {\"version\": \"2.1.0\", \"scope\": \"stampede1\"}}\nSep 23 14:41:03 node02 patroni[10577]: 2021-09-23 14:41:03,364 WARNING: Request failed to node3: GET http://node3:8008/patroni (HTTPConnectionPool(host='node3', port=8008): Max retries exceeded with url: /patroni (Caused by ConnectTimeoutError(&lt;urllib3.connection.HTTPConnection object at 0x7f57e06dffa0&gt;, 'Connection to node3 timed out. (connect timeout=2)')))\nSep 23 14:41:03 node02 patroni[10577]: 2021-09-23 14:41:03,373 INFO: Software Watchdog activated with 25 second timeout, timing slack 15 seconds\nSep 23 14:41:03 node02 patroni[10577]: 2021-09-23 14:41:03,385 INFO: promoted self to leader by acquiring session lock\nSep 23 14:41:03 node02 patroni[15478]: server promoting\nSep 23 14:41:03 node02 patroni[10577]: 2021-09-23 14:41:03,397 INFO: cleared rewind state after becoming the leader\nSep 23 14:41:04 node02 patroni[10577]: 2021-09-23 14:41:04,450 INFO: no action. I am (node2) the leader with the lock\nSep 23 14:41:04 node02 patroni[10577]: 2021-09-23 14:41:04,475 INFO: no action. I am (node2) the leader with the lock\n\u2026\n\u2026 \n</code></pre> <p><code>node2</code> realizes that the leader is dead, and promotes itself as the leader.</p> </li> <li> <p>Try accessing the cluster using the HAProxy endpoint at any point in time between these operations. The cluster is still accepting connections.</p> </li> </ol>"},{"location":"solutions/ha-test.html#manual-switchover","title":"Manual switchover","text":"<p>Typically, a manual switchover is needed for planned downtime to perform maintenance activity on the leader node. Patroni provides the <code>switchover</code> command to manually switch over from the leader node. </p> <p>Run the following command on <code>node2</code> (the current leader node):</p> <pre><code>$ sudo patronictl -c /etc/patroni/patroni.yml switchover\n</code></pre> <p>Patroni asks the name of the current primary node and then the node that should take over as the switched-over primary. You can also specify the time at which the switchover should happen. To trigger the process immediately, specify the value now:</p> <pre><code>primary [node2]: node2\nCandidate ['node1', 'node3'] []: node1\nWhen should the switchover take place (e.g. 2021-09-23T15:56 )  [now]: now\nCurrent cluster topology\n+ Cluster: stampede1 (7011110722654005156) -----------+\n| Member | Host  | Role    | State   | TL | Lag in MB |\n+--------+-------+---------+---------+----+-----------+\n| node1  | node1 | Replica | running |  3 |         0 |\n| node2  | node2 | Leader  | running |  3 |           |\n| node3  | node3 | Replica | stopped |    |   unknown |\n+--------+-------+---------+---------+----+-----------+\nAre you sure you want to switchover cluster stampede1, demoting current primary node2? [y/N]: y\n2021-09-23 14:56:40.54009 Successfully switched over to \"node1\"\n+ Cluster: stampede1 (7011110722654005156) -----------+\n| Member | Host  | Role    | State   | TL | Lag in MB |\n+--------+-------+---------+---------+----+-----------+\n| node1  | node1 | Leader  | running |  3 |           |\n| node2  | node2 | Replica | stopped |    |   unknown |\n| node3  | node3 | Replica | stopped |    |   unknown |\n+--------+-------+---------+---------+----+-----------+\n</code></pre> <p>Restart the Patroni service in <code>node2</code> (after the \u201cplanned maintenance\u201d). The node rejoins the cluster as a secondary.</p>"},{"location":"solutions/high-availability.html","title":"High Availability in PostgreSQL with Patroni","text":"<p>Summary</p> <ul> <li>Solution overview</li> <li>Cluster deployment</li> <li>Testing the cluster</li> </ul> <p>PostgreSQL has been widely adopted as a modern, high-performance transactional database. A highly available PostgreSQL cluster can withstand failures caused by network outages, resource saturation, hardware failures, operating system crashes, or unexpected reboots.  Such cluster is often a critical component of the enterprise application landscape, where four nines of availability is a minimum requirement. </p> <p>This document provides instructions on how to set up and test a highly-available, single-primary, three-node cluster with Percona PostgreSQL and Patroni. </p> <p>High availability overview</p> <p>There are a few methods for achieving high availability with PostgreSQL:</p> <ul> <li>shared disk failover, </li> <li>file system replication, </li> <li>trigger-based replication, </li> <li>statement-based replication, </li> <li>logical replication, and </li> <li>Write-Ahead Log (WAL) shipping.</li> </ul> <p>In recent times, PostgreSQL high availability is most commonly achieved with streaming replication.</p>"},{"location":"solutions/high-availability.html#streaming-replication","title":"Streaming replication","text":"<p>Streaming replication is part of Write-Ahead Log shipping, where changes to the WALs are immediately made available to standby replicas. With this approach, a standby instance is always up-to-date with changes from the primary node and can assume the role of primary in case of a failover.</p>"},{"location":"solutions/high-availability.html#why-native-streaming-replication-is-not-enough","title":"Why native streaming replication is not enough","text":"<p>Although the native streaming replication in PostgreSQL supports failing over  to the primary node, it lacks some key features expected from a truly highly-available solution. These include:</p> <ul> <li>No consensus-based promotion of a \u201cleader\u201d node during a failover</li> <li>No decent capability for monitoring cluster status </li> <li>No automated way to bring back the failed primary node to the cluster</li> <li>A manual or scheduled switchover is not easy to manage </li> </ul> <p>To address these shortcomings, there are a multitude of third-party, open-source extensions for PostgreSQL. The challenge for a database administrator here is to select the right utility for the current scenario. </p> <p>Percona Distribution for PostgreSQL solves this challenge by providing the Patroni extension for achieving PostgreSQL high availability.</p>"},{"location":"solutions/high-availability.html#patroni","title":"Patroni","text":"<p>Patroni provides a template-based approach to create highly available PostgreSQL clusters. Running atop the PostgreSQL streaming replication process, it integrates with watchdog functionality to detect failed primary nodes and take corrective actions to prevent outages. Patroni also provides a pluggable configuration store to manage distributed, multi-node cluster configuration and comes with REST APIs to monitor and manage the cluster. There is also a command-line utility called patronictl that helps manage switchovers and failure scenarios.</p>"},{"location":"solutions/high-availability.html#architecture-layout","title":"Architecture layout","text":"<p>The following diagram shows the architecture of a three-node PostgreSQL cluster with a single-leader node. </p> <p></p>"},{"location":"solutions/high-availability.html#components","title":"Components","text":"<p>The following are the components:</p> <ul> <li>Three PosgreSQL nodes: <code>node1</code>, <code>node2</code> and <code>node3</code></li> <li>A dedicated HAProxy node <code>HAProxy-demo</code>. HAProxy is an open-source load balancing software through which client connections to the cluster are routed.</li> <li>ETCD - a distributed configuration storage</li> <li>Softdog - a watchdog utility which is used to detect unhealthy nodes in an acceptable time frame.</li> </ul>"},{"location":"solutions/high-availability.html#deployment","title":"Deployment","text":"<p>Use the links below to navigate to the setup instructions relevant to your operating system</p> <ul> <li>Deploy on Debian or Ubuntu</li> <li>Deploy on Red Hat Enterprise Linux or CentOS</li> </ul>"},{"location":"solutions/high-availability.html#testing","title":"Testing","text":"<p>See the Testing PostgreSQL cluster for the guidelines on how to test your PostgreSQL cluster for replication, failure, switchover.</p>"}]}